/**
 * @license
 * Ideal Postcodes <https://ideal-postcodes.co.uk>
 * WooCommerce Integration
 * Copyright IDDQD Limited, all rights reserved
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.IdealPostcodes = {}));
})(this, (function (exports) { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  /**
   * @this {Promise}
   */
  function finallyConstructor(callback) {
    var constructor = this.constructor;
    return this.then(function (value) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function () {
        // @ts-ignore
        return constructor.reject(reason);
      });
    });
  }

  function allSettled(arr) {
    var P = this;
    return new P(function (resolve, reject) {
      if (!(arr && typeof arr.length !== 'undefined')) {
        return reject(new TypeError(_typeof(arr) + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));
      }

      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        if (val && (_typeof(val) === 'object' || typeof val === 'function')) {
          var then = val.then;

          if (typeof then === 'function') {
            then.call(val, function (val) {
              res(i, val);
            }, function (e) {
              args[i] = {
                status: 'rejected',
                reason: e
              };

              if (--remaining === 0) {
                resolve(args);
              }
            });
            return;
          }
        }

        args[i] = {
          status: 'fulfilled',
          value: val
        };

        if (--remaining === 0) {
          resolve(args);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  }

  // other code modifying setTimeout (like sinon.useFakeTimers())

  var setTimeoutFunc = setTimeout; // @ts-ignore

  var setImmediateFunc = typeof setImmediate !== 'undefined' ? setImmediate : null;

  function isArray$4(x) {
    return Boolean(x && typeof x.length !== 'undefined');
  }

  function noop() {} // Polyfill for Function.prototype.bind


  function bind$d(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }
  /**
   * @constructor
   * @param {Function} fn
   */


  function Promise$1(fn) {
    if (!(this instanceof Promise$1)) throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    /** @type {!number} */

    this._state = 0;
    /** @type {!boolean} */

    this._handled = false;
    /** @type {Promise|undefined} */

    this._value = undefined;
    /** @type {!Array<!Function>} */

    this._deferreds = [];
    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }

    if (self._state === 0) {
      self._deferreds.push(deferred);

      return;
    }

    self._handled = true;

    Promise$1._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;

      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }

      var ret;

      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }

      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');

      if (newValue && (_typeof(newValue) === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;

        if (newValue instanceof Promise$1) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind$d(then, newValue), self);
          return;
        }
      }

      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise$1._immediateFn(function () {
        if (!self._handled) {
          Promise$1._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }

    self._deferreds = null;
  }
  /**
   * @constructor
   */


  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }
  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */


  function doResolve(fn, self) {
    var done = false;

    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise$1.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise$1.prototype.then = function (onFulfilled, onRejected) {
    // @ts-ignore
    var prom = new this.constructor(noop);
    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise$1.prototype['finally'] = finallyConstructor;

  Promise$1.all = function (arr) {
    return new Promise$1(function (resolve, reject) {
      if (!isArray$4(arr)) {
        return reject(new TypeError('Promise.all accepts an array'));
      }

      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (_typeof(val) === 'object' || typeof val === 'function')) {
            var then = val.then;

            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }

          args[i] = val;

          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise$1.allSettled = allSettled;

  Promise$1.resolve = function (value) {
    if (value && _typeof(value) === 'object' && value.constructor === Promise$1) {
      return value;
    }

    return new Promise$1(function (resolve) {
      resolve(value);
    });
  };

  Promise$1.reject = function (value) {
    return new Promise$1(function (resolve, reject) {
      reject(value);
    });
  };

  Promise$1.race = function (arr) {
    return new Promise$1(function (resolve, reject) {
      if (!isArray$4(arr)) {
        return reject(new TypeError('Promise.race accepts an array'));
      }

      for (var i = 0, len = arr.length; i < len; i++) {
        Promise$1.resolve(arr[i]).then(resolve, reject);
      }
    });
  }; // Use polyfill for setImmediate for performance gains


  Promise$1._immediateFn = // @ts-ignore
  typeof setImmediateFunc === 'function' && function (fn) {
    // @ts-ignore
    setImmediateFunc(fn);
  } || function (fn) {
    setTimeoutFunc(fn, 0);
  };

  Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  /**
   * Default configuration
   */
  var defaults$4 = {
    tls: true,
    api_key: "",
    baseUrl: "api.ideal-postcodes.co.uk",
    version: "v1",
    strictAuthorisation: false,
    timeout: 10000,
    header: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    tags: [],
    agent: {}
  };
  /**
   * Client Class
   */

  var Client$1 = /*#__PURE__*/function () {
    function Client(config) {
      _classCallCheck(this, Client);

      this.config = _objectSpread$7(_objectSpread$7({}, defaults$4), config);
      this.config.header = _objectSpread$7(_objectSpread$7({}, defaults$4.header), config.header && config.header);
    }
    /**
     * Return base URL for API requests
     */


    _createClass(Client, [{
      key: "url",
      value: function url() {
        var _this$config = this.config,
            baseUrl = _this$config.baseUrl,
            version = _this$config.version;
        return "".concat(this.protocol(), "://").concat(baseUrl, "/").concat(version);
      }
    }, {
      key: "protocol",
      value: function protocol() {
        return this.config.tls ? "https" : "http";
      }
    }]);

    return Client;
  }();

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  /**
   * toQuery
   *
   * Shallow copies object while omitting undefined attributes
   */
  var toStringMap = function toStringMap(optional) {
    if (optional === undefined) return {};
    return Object.keys(optional).reduce(function (result, key) {
      var value = optional[key];
      var reduce = reduceStringMap(value);
      if (reduce.length > 0) result[key] = reduce;
      return result;
    }, {});
  };

  var isString$2 = function isString(i) {
    return typeof i === "string";
  };

  var isArray$3 = function isArray(i) {
    return Array.isArray(i);
  };

  var reduceStringMap = function reduceStringMap(value) {
    var result = [];

    if (isArray$3(value)) {
      value.forEach(function (val) {
        if (isNumber$1(val)) result.push(val.toString());
        if (isString$2(val)) result.push(val);
      });
      return result.join(",");
    }

    if (isNumber$1(value)) return value.toString();
    if (isString$2(value)) return value;
    return "";
  };

  var isNumber$1 = function isNumber(n) {
    return typeof n === "number";
  };
  /**
   * toTimeout
   *
   * Returns timeout value from request object. Delegates to default client
   * timeout if not specified
   */


  var toTimeout = function toTimeout(_ref, client) {
    var timeout = _ref.timeout;
    if (isNumber$1(timeout)) return timeout;
    return client.config.timeout;
  };
  /**
   * toHeader
   *
   * Extracts HTTP Header object from request and client default headers
   *
   * Precendence is given to request specific headers
   */

  var toHeader$1 = function toHeader(_ref2, client) {
    var _ref2$header = _ref2.header,
        header = _ref2$header === void 0 ? {} : _ref2$header;
    return _objectSpread$6(_objectSpread$6({}, client.config.header), toStringMap(header));
  };
  /**
   * toAuthHeader
   *
   * Extracts credentials into authorization header format
   */

  var toAuthHeader = function toAuthHeader(client, options) {
    var credentials = [];
    var api_key = options.api_key || client.config.api_key;
    credentials.push(["api_key", api_key]);
    var licensee = options.licensee;
    if (licensee !== undefined) credentials.push(["licensee", licensee]);
    var user_token = options.user_token;
    if (user_token !== undefined) credentials.push(["user_token", user_token]);
    return "IDEALPOSTCODES ".concat(toCredentialString(credentials));
  };
  /**
   * appendAuthorization
   *
   * Mutates a headers object to include Authorization header. Will insert if found:
   * - api_key
   * - licensee
   * - user_token
   */

  var appendAuthorization = function appendAuthorization(_ref3) {
    var header = _ref3.header,
        options = _ref3.options,
        client = _ref3.client;
    header.Authorization = toAuthHeader(client, options);
    return header;
  };

  var toCredentialString = function toCredentialString(credentials) {
    return credentials.map(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          key = _ref5[0],
          value = _ref5[1];

      return "".concat(key, "=\"").concat(value, "\"");
    }).join(" ");
  }; // Adds source IP to headers


  var appendIp = function appendIp(_ref6) {
    var header = _ref6.header,
        options = _ref6.options;
    var sourceIp = options.sourceIp;
    if (sourceIp !== undefined) header["IDPC-Source-IP"] = sourceIp;
    return header;
  }; // Adds filters to query

  var appendFilter = function appendFilter(_ref7) {
    var query = _ref7.query,
        options = _ref7.options;
    var filter = options.filter;
    if (filter !== undefined) query.filter = filter.join(",");
    return query;
  }; // Adds tags to query

  var appendTags = function appendTags(_ref8) {
    var client = _ref8.client,
        query = _ref8.query,
        options = _ref8.options;
    var tags;
    if (client.config.tags.length) tags = client.config.tags;
    if (options.tags) tags = options.tags;
    if (tags !== undefined) query.tags = tags.join(",");
    return query;
  }; // Adds pagination attributes to query

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _isNativeReflectConstruct$2() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct$2()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  // Take note of https://github.com/Microsoft/TypeScript/issues/13965

  /**
   * IdealPostcodesError
   *
   * Base error class for all API responses that return an error. This class
   * is used where a JSON body is not provided or invalid
   * E.g. 503 rate limit response, JSON parse failure response
   */
  var IdealPostcodesError$1 = /*#__PURE__*/function (_Error) {
    _inherits(IdealPostcodesError, _Error);

    var _super = _createSuper$1(IdealPostcodesError);

    /**
     * Instantiate IdealPostcodesError
     */
    function IdealPostcodesError(options) {
      var _this;

      _classCallCheck(this, IdealPostcodesError);

      var trueProto = (this instanceof IdealPostcodesError ? this.constructor : void 0).prototype;
      _this = _super.call(this);
      _this.__proto__ = trueProto;
      var message = options.message,
          httpStatus = options.httpStatus,
          _options$metadata = options.metadata,
          metadata = _options$metadata === void 0 ? {} : _options$metadata;
      _this.message = message;
      _this.name = "Ideal Postcodes Error";
      _this.httpStatus = httpStatus;
      _this.metadata = metadata;

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), IdealPostcodesError);
      }

      return _this;
    }

    return IdealPostcodesError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /**
   * IdpcApiError
   *
   * Base error class for API responses with a JSON body. Typically a subclass
   * will be used to capture the error category (e.g. 400, 401, 500, etc)
   */

  var IdpcApiError = /*#__PURE__*/function (_IdealPostcodesError) {
    _inherits(IdpcApiError, _IdealPostcodesError);

    var _super2 = _createSuper$1(IdpcApiError);

    /**
     * Returns an API error instance
     */
    function IdpcApiError(httpResponse) {
      var _this2;

      _classCallCheck(this, IdpcApiError);

      _this2 = _super2.call(this, {
        httpStatus: httpResponse.httpStatus,
        message: httpResponse.body.message
      });
      _this2.response = httpResponse;
      return _this2;
    }

    return IdpcApiError;
  }(IdealPostcodesError$1);
  /**
   * IdpcBadRequestError
   *
   * Captures API responses that return a 400 (Bad Request Error) response
   *
   * Examples include:
   * - Invalid syntax submitted
   * - Invalid date range submitted
   * - Invalid tag submitted
   */

  var IdpcBadRequestError = /*#__PURE__*/function (_IdpcApiError) {
    _inherits(IdpcBadRequestError, _IdpcApiError);

    var _super3 = _createSuper$1(IdpcBadRequestError);

    function IdpcBadRequestError() {
      _classCallCheck(this, IdpcBadRequestError);

      return _super3.apply(this, arguments);
    }

    return IdpcBadRequestError;
  }(IdpcApiError);
  /**
   * IdpcUnauthorisedError
   *
   * Captures API responses that return a 401 (Unauthorised) response
   *
   * Examples include:
   * - Invalid api_key
   * - Invalid user_token
   * - Invalid licensee
   */

  var IdpcUnauthorisedError = /*#__PURE__*/function (_IdpcApiError2) {
    _inherits(IdpcUnauthorisedError, _IdpcApiError2);

    var _super4 = _createSuper$1(IdpcUnauthorisedError);

    function IdpcUnauthorisedError() {
      _classCallCheck(this, IdpcUnauthorisedError);

      return _super4.apply(this, arguments);
    }

    return IdpcUnauthorisedError;
  }(IdpcApiError);
  /**
   * IpdcInvalidKeyError
   *
   * Invalid API Key presented for request
   */

  var IdpcInvalidKeyError = /*#__PURE__*/function (_IdpcUnauthorisedErro) {
    _inherits(IdpcInvalidKeyError, _IdpcUnauthorisedErro);

    var _super5 = _createSuper$1(IdpcInvalidKeyError);

    function IdpcInvalidKeyError() {
      _classCallCheck(this, IdpcInvalidKeyError);

      return _super5.apply(this, arguments);
    }

    return IdpcInvalidKeyError;
  }(IdpcUnauthorisedError);
  /**
   * IdpcRequestFailedError
   *
   * Captures API responses that return a 402 (Request Failed) response
   *
   * Examples include:
   * - Key balance depleted
   * - Daily key limit reached
   */

  var IdpcRequestFailedError = /*#__PURE__*/function (_IdpcApiError3) {
    _inherits(IdpcRequestFailedError, _IdpcApiError3);

    var _super6 = _createSuper$1(IdpcRequestFailedError);

    function IdpcRequestFailedError() {
      _classCallCheck(this, IdpcRequestFailedError);

      return _super6.apply(this, arguments);
    }

    return IdpcRequestFailedError;
  }(IdpcApiError);
  /**
   * IdpcBalanceDepleted
   *
   * Balance on key has been depleted
   */

  var IdpcBalanceDepletedError = /*#__PURE__*/function (_IdpcRequestFailedErr) {
    _inherits(IdpcBalanceDepletedError, _IdpcRequestFailedErr);

    var _super7 = _createSuper$1(IdpcBalanceDepletedError);

    function IdpcBalanceDepletedError() {
      _classCallCheck(this, IdpcBalanceDepletedError);

      return _super7.apply(this, arguments);
    }

    return IdpcBalanceDepletedError;
  }(IdpcRequestFailedError);
  /**
   * IdpcLimitReachedError
   *
   * Limit reached. One of your lookup limits has been breached for today. This
   * could either be your total daily limit on your key or the individual IP
   * limit. You can either wait for for the limit to reset (after a day) or
   * manually disable or increase your limit.
   */

  var IdpcLimitReachedError = /*#__PURE__*/function (_IdpcRequestFailedErr2) {
    _inherits(IdpcLimitReachedError, _IdpcRequestFailedErr2);

    var _super8 = _createSuper$1(IdpcLimitReachedError);

    function IdpcLimitReachedError() {
      _classCallCheck(this, IdpcLimitReachedError);

      return _super8.apply(this, arguments);
    }

    return IdpcLimitReachedError;
  }(IdpcRequestFailedError);
  /**
   * IdpcResourceNotFoundError
   *
   * Captures API responses that return a 404 (Resource Not Found) response
   *
   * Examples include:
   * - Postcode not found
   * - UDPRN not found
   * - Key not found
   */

  var IdpcResourceNotFoundError = /*#__PURE__*/function (_IdpcApiError4) {
    _inherits(IdpcResourceNotFoundError, _IdpcApiError4);

    var _super9 = _createSuper$1(IdpcResourceNotFoundError);

    function IdpcResourceNotFoundError() {
      _classCallCheck(this, IdpcResourceNotFoundError);

      return _super9.apply(this, arguments);
    }

    return IdpcResourceNotFoundError;
  }(IdpcApiError);
  /**
   * IdpcPostcodeNotFoundError
   *
   * Requested postcode does not exist
   */

  var IdpcPostcodeNotFoundError = /*#__PURE__*/function (_IdpcResourceNotFound) {
    _inherits(IdpcPostcodeNotFoundError, _IdpcResourceNotFound);

    var _super10 = _createSuper$1(IdpcPostcodeNotFoundError);

    function IdpcPostcodeNotFoundError() {
      _classCallCheck(this, IdpcPostcodeNotFoundError);

      return _super10.apply(this, arguments);
    }

    return IdpcPostcodeNotFoundError;
  }(IdpcResourceNotFoundError);
  /**
   * IdpcKeyNotFoundError
   *
   * Requested API Key does not exist
   */

  var IdpcKeyNotFoundError = /*#__PURE__*/function (_IdpcResourceNotFound2) {
    _inherits(IdpcKeyNotFoundError, _IdpcResourceNotFound2);

    var _super11 = _createSuper$1(IdpcKeyNotFoundError);

    function IdpcKeyNotFoundError() {
      _classCallCheck(this, IdpcKeyNotFoundError);

      return _super11.apply(this, arguments);
    }

    return IdpcKeyNotFoundError;
  }(IdpcResourceNotFoundError);
  /**
   * IdpcUdprnNotFoundError
   *
   * Requested UDPRN does not exist
   */

  var IdpcUdprnNotFoundError = /*#__PURE__*/function (_IdpcResourceNotFound3) {
    _inherits(IdpcUdprnNotFoundError, _IdpcResourceNotFound3);

    var _super12 = _createSuper$1(IdpcUdprnNotFoundError);

    function IdpcUdprnNotFoundError() {
      _classCallCheck(this, IdpcUdprnNotFoundError);

      return _super12.apply(this, arguments);
    }

    return IdpcUdprnNotFoundError;
  }(IdpcResourceNotFoundError);
  /**
   * IdpcUmprnNotFoundError
   *
   * Requested UMPRN does not exist
   */

  var IdpcUmprnNotFoundError = /*#__PURE__*/function (_IdpcResourceNotFound4) {
    _inherits(IdpcUmprnNotFoundError, _IdpcResourceNotFound4);

    var _super13 = _createSuper$1(IdpcUmprnNotFoundError);

    function IdpcUmprnNotFoundError() {
      _classCallCheck(this, IdpcUmprnNotFoundError);

      return _super13.apply(this, arguments);
    }

    return IdpcUmprnNotFoundError;
  }(IdpcResourceNotFoundError);
  /**
   * IdpcServerError
   *
   * Captures API responses that return a 500 (Server Error) response
   */

  var IdpcServerError = /*#__PURE__*/function (_IdpcApiError5) {
    _inherits(IdpcServerError, _IdpcApiError5);

    var _super14 = _createSuper$1(IdpcServerError);

    function IdpcServerError() {
      _classCallCheck(this, IdpcServerError);

      return _super14.apply(this, arguments);
    }

    return IdpcServerError;
  }(IdpcApiError); // 200 Responses

  var OK = 200; // 300 Responses

  var REDIRECT = 300; // 400 Responses

  var BAD_REQUEST = 400; // 401 Responses

  var UNAUTHORISED = 401;
  var INVALID_KEY = 4010; // 402 Responses

  var PAYMENT_REQUIRED = 402;
  var BALANCE_DEPLETED = 4020;
  var LIMIT_REACHED = 4021; // 404 Responses

  var NOT_FOUND = 404;
  var POSTCODE_NOT_FOUND = 4040;
  var KEY_NOT_FOUND = 4042;
  var UDPRN_NOT_FOUND = 4044;
  var UMPRN_NOT_FOUND = 4046; // 500 Responses

  var SERVER_ERROR = 500;

  var isSuccess = function isSuccess(code) {
    if (code < OK) return false;
    if (code >= REDIRECT) return false;
    return true;
  };

  var isObject$d = function isObject(o) {
    if (o === null) return false;
    if (_typeof(o) !== "object") return false;
    return true;
  };

  var isErrorResponse = function isErrorResponse(body) {
    if (!isObject$d(body)) return false;
    if (typeof body.message !== "string") return false;
    if (typeof body.code !== "number") return false;
    return true;
  };
  /**
   * parse
   *
   * Parses API responses and returns an error for non 2xx responses
   *
   * Upon detecting an error an instance of IdealPostcodesError is returned
   */


  var parse = function parse(response) {
    var httpStatus = response.httpStatus,
        body = response.body;
    if (isSuccess(httpStatus)) return;

    if (isErrorResponse(body)) {
      // Test for specific API errors of interest
      var code = body.code;
      if (code === INVALID_KEY) return new IdpcInvalidKeyError(response);
      if (code === POSTCODE_NOT_FOUND) return new IdpcPostcodeNotFoundError(response);
      if (code === KEY_NOT_FOUND) return new IdpcKeyNotFoundError(response);
      if (code === UDPRN_NOT_FOUND) return new IdpcUdprnNotFoundError(response);
      if (code === UMPRN_NOT_FOUND) return new IdpcUmprnNotFoundError(response);
      if (code === BALANCE_DEPLETED) return new IdpcBalanceDepletedError(response);
      if (code === LIMIT_REACHED) return new IdpcLimitReachedError(response); // If no API errors of interest detected, fall back to http status code

      if (httpStatus === NOT_FOUND) return new IdpcResourceNotFoundError(response);
      if (httpStatus === BAD_REQUEST) return new IdpcBadRequestError(response);
      if (httpStatus === PAYMENT_REQUIRED) return new IdpcRequestFailedError(response);
      if (httpStatus === UNAUTHORISED) return new IdpcUnauthorisedError(response);
      if (httpStatus === SERVER_ERROR) return new IdpcServerError(response);
    } // Generate generic error (backstop)


    return new IdealPostcodesError$1({
      httpStatus: httpStatus,
      message: JSON.stringify(body)
    });
  };

  var toRetrieveUrl = function toRetrieveUrl(options, id) {
    return [options.client.url(), options.resource, encodeURIComponent(id), options.action].filter(function (e) {
      return e !== undefined;
    }).join("/");
  };

  var retrieveMethod = function retrieveMethod(options) {
    var client = options.client;
    return function (id, request) {
      return client.config.agent.http({
        method: "GET",
        url: toRetrieveUrl(options, id),
        query: toStringMap(request.query),
        header: toHeader$1(request, client),
        timeout: toTimeout(request, client)
      }).then(function (response) {
        var error = parse(response);
        if (error) throw error;
        return response;
      });
    };
  };
  var listMethod = function listMethod(options) {
    var client = options.client,
        resource = options.resource;
    return function (request) {
      return client.config.agent.http({
        method: "GET",
        url: "".concat(client.url(), "/").concat(resource),
        query: toStringMap(request.query),
        header: toHeader$1(request, client),
        timeout: toTimeout(request, client)
      }).then(function (response) {
        var error = parse(response);
        if (error) throw error;
        return response;
      });
    };
  };

  var resource$3 = "autocomplete/addresses";
  var list = function list(client, request) {
    return listMethod({
      resource: resource$3,
      client: client
    })(request);
  };

  var resource$2 = "keys";
  var retrieve$2 = function retrieve(client, apiKey, request) {
    return retrieveMethod({
      resource: resource$2,
      client: client
    })(apiKey, request);
  };

  var resource$1 = "udprn";
  var retrieve$1 = function retrieve(client, udprn, request) {
    return retrieveMethod({
      resource: resource$1,
      client: client
    })(udprn, request);
  };

  var resource = "umprn";
  var retrieve = function retrieve(client, umprn, request) {
    return retrieveMethod({
      resource: resource,
      client: client
    })(umprn, request);
  };

  /**
   * @module
   *
   * API Helper Methods
   *
   * Exports simple methods for common API tasks
   */
  /**
   * Generates a request object. Bundles together commonly used header/query extractions:
   * - Authorization (api_key, licensee, user_token)
   * - Source IP forwarding
   * - Result filtering
   * - Tagging
   */

  var toAddressIdQuery = function toAddressIdQuery(options) {
    var header = {};
    var query = {};
    var client = options.client;
    appendAuthorization({
      client: client,
      header: header,
      options: options
    });
    appendIp({
      header: header,
      options: options
    });
    appendFilter({
      query: query,
      options: options
    });
    appendTags({
      client: client,
      query: query,
      options: options
    });
    var request = {
      header: header,
      query: query
    };
    if (options.timeout !== undefined) request.timeout = options.timeout;
    return request;
  };
  /**
   * Lookup UDPRN
   *
   * Search for an address given a UDPRN
   *
   * Invalid UDPRN returns `null`
   *
   * [API Documentation for /udprn](https://ideal-postcodes.co.uk/documentation/udprn)
   */


  var lookupUdprn = function lookupUdprn(options) {
    var queryOptions = toAddressIdQuery(options);
    return retrieve$1(options.client, options.udprn.toString(), queryOptions).then(function (response) {
      return response.body.result;
    }).catch(function (error) {
      if (error instanceof IdpcUdprnNotFoundError) return null;
      throw error;
    });
  };
  /**
   * Lookup UMPRN
   *
   * Search for an address given a UDPRN
   *
   * Invalid UDPRN returns `null`
   *
   * [API Documentation for /udprn](https://ideal-postcodes.co.uk/documentation/udprn)
   */

  var lookupUmprn = function lookupUmprn(options) {
    var queryOptions = toAddressIdQuery(options);
    return retrieve(options.client, options.umprn.toString(), queryOptions).then(function (response) {
      return response.body.result;
    }).catch(function (error) {
      if (error instanceof IdpcUmprnNotFoundError) return null;
      throw error;
    });
  };
  /**
   * Check Key Availability
   *
   * Checks if a key can bey used
   *
   * [API Documentation for /keys]()https://ideal-postcodes.co.uk/documentation/keys#key)
   */

  var checkKeyUsability = function checkKeyUsability(options) {
    var client = options.client,
        timeout = options.timeout;
    var api_key = options.api_key || options.client.config.api_key;
    var licensee = options.licensee;
    var query;

    if (licensee === undefined) {
      query = {};
    } else {
      query = {
        licensee: licensee
      };
    }

    var queryOptions = {
      query: query,
      header: {}
    };
    if (timeout !== undefined) queryOptions.timeout = timeout;
    return retrieve$2(client, api_key, queryOptions).then(function (response) {
      return response.body.result;
    }); // Assert that we're retrieving public key information as no user_token provided
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var axios$2 = {exports: {}};

  var bind$c = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);

      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      return fn.apply(thisArg, args);
    };
  };

  var bind$b = bind$c;
  /*global toString:true*/
  // utils is a library of generic helper functions non-specific to axios

  var toString$6 = Object.prototype.toString;
  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */

  function isArray$2(val) {
    return toString$6.call(val) === '[object Array]';
  }
  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */


  function isUndefined(val) {
    return typeof val === 'undefined';
  }
  /**
   * Determine if a value is a Buffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Buffer, otherwise false
   */


  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
  }
  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */


  function isArrayBuffer(val) {
    return toString$6.call(val) === '[object ArrayBuffer]';
  }
  /**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */


  function isFormData(val) {
    return typeof FormData !== 'undefined' && val instanceof FormData;
  }
  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */


  function isArrayBufferView(val) {
    var result;

    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }

    return result;
  }
  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */


  function isString$1(val) {
    return typeof val === 'string';
  }
  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */


  function isNumber(val) {
    return typeof val === 'number';
  }
  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */


  function isObject$c(val) {
    return val !== null && _typeof(val) === 'object';
  }
  /**
   * Determine if a value is a plain Object
   *
   * @param {Object} val The value to test
   * @return {boolean} True if value is a plain Object, otherwise false
   */


  function isPlainObject(val) {
    if (toString$6.call(val) !== '[object Object]') {
      return false;
    }

    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */


  function isDate(val) {
    return toString$6.call(val) === '[object Date]';
  }
  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */


  function isFile(val) {
    return toString$6.call(val) === '[object File]';
  }
  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */


  function isBlob(val) {
    return toString$6.call(val) === '[object Blob]';
  }
  /**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */


  function isFunction(val) {
    return toString$6.call(val) === '[object Function]';
  }
  /**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */


  function isStream(val) {
    return isObject$c(val) && isFunction(val.pipe);
  }
  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */


  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }
  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */


  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }
  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */


  function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
      return false;
    }

    return typeof window !== 'undefined' && typeof document !== 'undefined';
  }
  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */


  function forEach$1(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    } // Force an array if not already something iterable


    if (_typeof(obj) !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray$2(obj)) {
      // Iterate over array values
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */


  function merge() {
    var result = {};

    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray$2(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach$1(arguments[i], assignValue);
    }

    return result;
  }
  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */


  function extend(a, b, thisArg) {
    forEach$1(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind$b(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  /**
   * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
   *
   * @param {string} content with BOM
   * @return {string} content value without BOM
   */


  function stripBOM(content) {
    if (content.charCodeAt(0) === 0xFEFF) {
      content = content.slice(1);
    }

    return content;
  }

  var utils$d = {
    isArray: isArray$2,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString$1,
    isNumber: isNumber,
    isObject: isObject$c,
    isPlainObject: isPlainObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach$1,
    merge: merge,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM
  };

  var utils$c = utils$d;

  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
  }
  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */


  var buildURL$2 = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    var serializedParams;

    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils$c.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils$c.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }

        if (utils$c.isArray(val)) {
          key = key + '[]';
        } else {
          val = [val];
        }

        utils$c.forEach(val, function parseValue(v) {
          if (utils$c.isDate(v)) {
            v = v.toISOString();
          } else if (utils$c.isObject(v)) {
            v = JSON.stringify(v);
          }

          parts.push(encode(key) + '=' + encode(v));
        });
      });
      serializedParams = parts.join('&');
    }

    if (serializedParams) {
      var hashmarkIndex = url.indexOf('#');

      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  };

  var utils$b = utils$d;

  function InterceptorManager$1() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */


  InterceptorManager$1.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected
    });
    return this.handlers.length - 1;
  };
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */


  InterceptorManager$1.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */


  InterceptorManager$1.prototype.forEach = function forEach(fn) {
    utils$b.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };

  var InterceptorManager_1 = InterceptorManager$1;

  var utils$a = utils$d;
  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */

  var transformData$1 = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils$a.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });
    return data;
  };

  var isCancel$1 = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };

  var utils$9 = utils$d;

  var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
    utils$9.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The error.
   */


  var enhanceError$1 = function enhanceError(error, config, code, request, response) {
    error.config = config;

    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };

    return error;
  };

  var enhanceError = enhanceError$1;
  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The created error.
   */

  var createError$2 = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };

  var createError$1 = createError$2;
  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   */

  var settle$1 = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;

    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError$1('Request failed with status code ' + response.status, response.config, null, response.request, response));
    }
  };

  var utils$8 = utils$d;
  var cookies$1 = utils$8.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils$8.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils$8.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils$8.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  }() : // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() {
        return null;
      },
      remove: function remove() {}
    };
  }();

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */


  var isAbsoluteURL$1 = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */


  var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
  };

  var isAbsoluteURL = isAbsoluteURL$1;
  var combineURLs = combineURLs$1;
  /**
   * Creates a new URL by combining the baseURL with the requestedURL,
   * only when the requestedURL is not already an absolute URL.
   * If the requestURL is absolute, this function returns the requestedURL untouched.
   *
   * @param {string} baseURL The base URL
   * @param {string} requestedURL Absolute or relative URL to combine
   * @returns {string} The combined full path
   */

  var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }

    return requestedURL;
  };

  var utils$7 = utils$d; // Headers whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers

  var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */

  var parseHeaders$1 = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) {
      return parsed;
    }

    utils$7.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils$7.trim(line.substr(0, i)).toLowerCase();
      val = utils$7.trim(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }

        if (key === 'set-cookie') {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
    });
    return parsed;
  };

  var utils$6 = utils$d;
  var isURLSameOrigin$1 = utils$6.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */

    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */

    return function isURLSameOrigin(requestURL) {
      var parsed = utils$6.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();

  var utils$5 = utils$d;
  var settle = settle$1;
  var cookies = cookies$1;
  var buildURL$1 = buildURL$2;
  var buildFullPath = buildFullPath$1;
  var parseHeaders = parseHeaders$1;
  var isURLSameOrigin = isURLSameOrigin$1;
  var createError = createError$2;

  var xhr = function xhrAdapter(config) {
    return new Promise$1(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;

      if (utils$5.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest(); // HTTP basic authentication

      if (config.auth) {
        var username = config.auth.username || '';
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
      }

      var fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

      request.timeout = config.timeout; // Listen for ready state

      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        } // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request


        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        } // Prepare the response


        var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };
        settle(resolve, reject, response); // Clean up request

        request = null;
      }; // Handle browser request cancellation (as opposed to a manual cancellation)


      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

        request = null;
      }; // Handle low level network errors


      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError('Network Error', config, null, request)); // Clean up request

        request = null;
      }; // Handle timeout


      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }

        reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

        request = null;
      }; // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.


      if (utils$5.isStandardBrowserEnv()) {
        // Add xsrf header
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      } // Add headers to the request


      if ('setRequestHeader' in request) {
        utils$5.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      } // Add withCredentials to request if needed


      if (!utils$5.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      } // Add responseType to request if needed


      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
          // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
          if (config.responseType !== 'json') {
            throw e;
          }
        }
      } // Handle progress if needed


      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', config.onDownloadProgress);
      } // Not all browsers support upload events


      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', config.onUploadProgress);
      }

      if (config.cancelToken) {
        // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }

          request.abort();
          reject(cancel); // Clean up request

          request = null;
        });
      }

      if (!requestData) {
        requestData = null;
      } // Send the request


      request.send(requestData);
    });
  };

  var utils$4 = utils$d;
  var normalizeHeaderName = normalizeHeaderName$1;
  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  function setContentTypeIfUnset(headers, value) {
    if (!utils$4.isUndefined(headers) && utils$4.isUndefined(headers['Content-Type'])) {
      headers['Content-Type'] = value;
    }
  }

  function getDefaultAdapter() {
    var adapter;

    if (typeof XMLHttpRequest !== 'undefined') {
      // For browsers use XHR adapter
      adapter = xhr;
    } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
      // For node use HTTP adapter
      adapter = xhr;
    }

    return adapter;
  }

  var defaults$3 = {
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, 'Accept');
      normalizeHeaderName(headers, 'Content-Type');

      if (utils$4.isFormData(data) || utils$4.isArrayBuffer(data) || utils$4.isBuffer(data) || utils$4.isStream(data) || utils$4.isFile(data) || utils$4.isBlob(data)) {
        return data;
      }

      if (utils$4.isArrayBufferView(data)) {
        return data.buffer;
      }

      if (utils$4.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
        return data.toString();
      }

      if (utils$4.isObject(data)) {
        setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
        return JSON.stringify(data);
      }

      return data;
    }],
    transformResponse: [function transformResponse(data) {
      /*eslint no-param-reassign:0*/
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) {
          /* Ignore */
        }
      }

      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults$3.headers = {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  };
  utils$4.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults$3.headers[method] = {};
  });
  utils$4.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults$3.headers[method] = utils$4.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$3;

  var utils$3 = utils$d;
  var transformData = transformData$1;
  var isCancel = isCancel$1;
  var defaults$2 = defaults_1;
  /**
   * Throws a `Cancel` if cancellation has been requested.
   */

  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */


  var dispatchRequest$1 = function dispatchRequest(config) {
    throwIfCancellationRequested(config); // Ensure headers exist

    config.headers = config.headers || {}; // Transform request data

    config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

    config.headers = utils$3.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils$3.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults$2.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config); // Transform response data

      response.data = transformData(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config); // Transform response data

        if (reason && reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }

      return Promise$1.reject(reason);
    });
  };

  var utils$2 = utils$d;
  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */

  var mergeConfig$2 = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ['url', 'method', 'data'];
    var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
    var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
    var directMergeKeys = ['validateStatus'];

    function getMergedValue(target, source) {
      if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
        return utils$2.merge(target, source);
      } else if (utils$2.isPlainObject(source)) {
        return utils$2.merge({}, source);
      } else if (utils$2.isArray(source)) {
        return source.slice();
      }

      return source;
    }

    function mergeDeepProperties(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    }

    utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(undefined, config2[prop]);
      }
    });
    utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(undefined, config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    });
    utils$2.forEach(directMergeKeys, function merge(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(undefined, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils$2.forEach(otherKeys, mergeDeepProperties);
    return config;
  };

  var utils$1 = utils$d;
  var buildURL = buildURL$2;
  var InterceptorManager = InterceptorManager_1;
  var dispatchRequest = dispatchRequest$1;
  var mergeConfig$1 = mergeConfig$2;
  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */

  function Axios$1(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */


  Axios$1.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }

    config = mergeConfig$1(this.defaults, config); // Set config.method

    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = 'get';
    } // Hook up interceptors middleware


    var chain = [dispatchRequest, undefined];
    var promise = Promise$1.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  };

  Axios$1.prototype.getUri = function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
  }; // Provide aliases for supported request methods


  utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios$1.prototype[method] = function (url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method: method,
        url: url,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios$1.prototype[method] = function (url, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });
  var Axios_1 = Axios$1;

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */


  function Cancel$1(message) {
    this.message = message;
  }

  Cancel$1.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel$1.prototype.__CANCEL__ = true;
  var Cancel_1 = Cancel$1;

  var Cancel = Cancel_1;
  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */

  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise$1(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new Cancel(message);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `Cancel` if cancellation has been requested.
   */


  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */


  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };

  var CancelToken_1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */


  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };

  /**
   * Determines whether the payload is an error thrown by Axios
   *
   * @param {*} payload The value to test
   * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
   */


  var isAxiosError = function isAxiosError(payload) {
    return _typeof(payload) === 'object' && payload.isAxiosError === true;
  };

  var utils = utils$d;
  var bind$a = bind$c;
  var Axios = Axios_1;
  var mergeConfig = mergeConfig$2;
  var defaults$1 = defaults_1;
  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */

  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind$a(Axios.prototype.request, context); // Copy axios.prototype to instance

    utils.extend(instance, Axios.prototype, context); // Copy context to instance

    utils.extend(instance, context);
    return instance;
  } // Create the default instance to be exported


  var axios$1 = createInstance(defaults$1); // Expose Axios class to allow class inheritance

  axios$1.Axios = Axios; // Factory for creating new instances

  axios$1.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
  }; // Expose Cancel & CancelToken


  axios$1.Cancel = Cancel_1;
  axios$1.CancelToken = CancelToken_1;
  axios$1.isCancel = isCancel$1; // Expose all/spread

  axios$1.all = function all(promises) {
    return Promise$1.all(promises);
  };

  axios$1.spread = spread; // Expose isAxiosError

  axios$1.isAxiosError = isAxiosError;
  axios$2.exports = axios$1; // Allow use of default import syntax in TypeScript

  axios$2.exports.default = axios$1;

  var axios = axios$2.exports;

  var IdealPostcodesError = IdealPostcodesError$1;
  /**
   * Converts a Got header object to one that can be used by the client
   *
   * @hidden
   */

  var toHeader = function toHeader(gotHeaders) {
    return Object.keys(gotHeaders).reduce(function (headers, key) {
      var val = gotHeaders[key];

      if (typeof val === "string") {
        headers[key] = val;
      } else if (Array.isArray(val)) {
        headers[key] = val.join(",");
      }

      return headers;
    }, {});
  };
  /**
   * Adapts got responses to a format consumable by core-interface
   *
   * @hidden
   */

  var toHttpResponse = function toHttpResponse(httpRequest, response) {
    return {
      httpRequest: httpRequest,
      body: response.data,
      httpStatus: response.status || 0,
      header: toHeader(response.headers),
      metadata: {
        response: response
      }
    };
  };
  /**
   * Catch non-response errors (e.g. network failure, DNS failure, timeout)
   * wrap in our Error class and return
   *
   * @hidden
   */


  var handleError = function handleError(error) {
    var idpcError = new IdealPostcodesError({
      message: "[".concat(error.name, "] ").concat(error.message),
      httpStatus: 0,
      metadata: {
        axios: error
      }
    });
    return Promise$1.reject(idpcError);
  }; // Don't throw errors for any HTTP status code
  // Allow core-interface to absorb these and emit own errors


  var validateStatus = function validateStatus() {
    return true;
  };
  /**
   * Agent
   *
   * @hidden
   */


  var Agent = /*#__PURE__*/function () {
    function Agent() {
      _classCallCheck(this, Agent);

      this.Axios = axios.create({
        validateStatus: validateStatus
      });
    }

    _createClass(Agent, [{
      key: "requestWithBody",
      value: function requestWithBody(httpRequest) {
        var body = httpRequest.body,
            method = httpRequest.method,
            timeout = httpRequest.timeout,
            url = httpRequest.url,
            header = httpRequest.header,
            query = httpRequest.query;
        return this.Axios.request({
          url: url,
          method: method,
          headers: header,
          params: query,
          data: body,
          timeout: timeout
        }).then(function (response) {
          return toHttpResponse(httpRequest, response);
        }).catch(handleError);
      }
    }, {
      key: "request",
      value: function request(httpRequest) {
        var method = httpRequest.method,
            timeout = httpRequest.timeout,
            url = httpRequest.url,
            header = httpRequest.header,
            query = httpRequest.query;
        return this.Axios.request({
          url: url,
          method: method,
          headers: header,
          params: query,
          timeout: timeout
        }).then(function (response) {
          return toHttpResponse(httpRequest, response);
        }).catch(handleError);
      }
    }, {
      key: "http",
      value: function http(httpRequest) {
        if (httpRequest.body !== undefined) return this.requestWithBody(httpRequest);
        return this.request(httpRequest);
      }
    }]);

    return Agent;
  }();

  function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Client = /*#__PURE__*/function (_CoreInterface) {
    _inherits(Client, _CoreInterface);

    var _super = _createSuper(Client);

    /**
     * Client constructor extends CoreInterface
     */
    function Client(config) {
      _classCallCheck(this, Client);

      var agent = new Agent();
      return _super.call(this, _objectSpread$5({
        agent: agent
      }, config));
    }

    return Client;
  }(Client$1);

  var isString = function isString(input) {
    return typeof input === "string";
  };

  var hasWindow$1 = function hasWindow() {
    return typeof window !== "undefined";
  };
  var toArray = function toArray(nodeList) {
    return Array.prototype.slice.call(nodeList);
  };
  var loaded = function loaded(elem) {
    return elem.getAttribute("idpc") === "true";
  };
  var markLoaded = function markLoaded(elem) {
    return elem.setAttribute("idpc", "true");
  };

  var isTrue$1 = function isTrue() {
    return true;
  };

  var getParent = function getParent(node, entity) {
    var test = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isTrue$1;
    var parent = node;
    var tagName = entity.toUpperCase();

    while (parent.tagName !== "HTML") {
      if (parent.tagName === tagName && test(parent)) return parent;
      if (parent.parentNode === null) return null;
      parent = parent.parentNode;
    }

    return null;
  };
  var toHtmlElem = function toHtmlElem(parent, selector) {
    return selector ? parent.querySelector(selector) : null;
  };
  var toElem = function toElem(elem, context) {
    if (isString(elem)) return context.querySelector(elem);
    return elem;
  };

  var d$1 = function d() {
    return window.document;
  };

  var getScope = function getScope(scope) {
    if (isString(scope)) return d$1().querySelector(scope);
    if (scope === null) return d$1();
    return scope;
  };
  var getDocument = function getDocument(scope) {
    if (scope instanceof Document) return scope;
    if (scope.ownerDocument) return scope.ownerDocument;
    return d$1();
  };
  var setStyle = function setStyle(element, style) {
    var currentRules = element.getAttribute("style");
    Object.keys(style).forEach(function (key) {
      return element.style[key] = style[key];
    });
    return currentRules;
  };
  var restoreStyle = function restoreStyle(element, style) {
    element.setAttribute("style", style || "");
  };
  var hide = function hide(e) {
    e.style.display = "none";
    return e;
  };
  var show = function show(e) {
    e.style.display = "";
    return e;
  };
  var remove = function remove(elem) {
    if (elem === null || elem.parentNode === null) return;
    elem.parentNode.removeChild(elem);
  };
  var contains = function contains(scope, selector, text) {
    var elements = scope.querySelectorAll(selector);

    for (var i = 0; i < elements.length; i++) {
      var e = elements[i];
      var content = e.innerText;
      if (content && content.trim() === text) return e;
    }

    return null;
  };

  var generateTimer = function generateTimer(_ref) {
    var pageTest = _ref.pageTest,
        bind = _ref.bind,
        _ref$interval = _ref.interval,
        interval = _ref$interval === void 0 ? 1000 : _ref$interval;
    var timer = null;

    var start = function start(config) {
      if (!pageTest()) return null;
      timer = window.setInterval(function () {
        try {
          bind(config);
        } catch (e) {
          stop();
          console.log(e);
        }
      }, interval);
      return timer;
    };

    var stop = function stop() {
      if (timer === null) return;
      window.clearInterval(timer);
      timer = null;
    };

    return {
      start: start,
      stop: stop
    };
  };
  var cssEscape = function cssEscape(value) {
    value = String(value);
    var length = value.length;
    var index = -1;
    var codeUnit;
    var result = "";
    var firstCodeUnit = value.charCodeAt(0);

    while (++index < length) {
      codeUnit = value.charCodeAt(index);

      if (codeUnit == 0x0000) {
        result += "\uFFFD";
        continue;
      }

      if (codeUnit >= 0x0001 && codeUnit <= 0x001f || codeUnit == 0x007f || index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039 || index == 1 && codeUnit >= 0x0030 && codeUnit <= 0x0039 && firstCodeUnit == 0x002d) {
        result += "\\" + codeUnit.toString(16) + " ";
        continue;
      }

      if (index == 0 && length == 1 && codeUnit == 0x002d) {
        result += "\\" + value.charAt(index);
        continue;
      }

      if (codeUnit >= 0x0080 || codeUnit == 0x002d || codeUnit == 0x005f || codeUnit >= 0x0030 && codeUnit <= 0x0039 || codeUnit >= 0x0041 && codeUnit <= 0x005a || codeUnit >= 0x0061 && codeUnit <= 0x007a) {
        result += value.charAt(index);
        continue;
      }

      result += "\\" + value.charAt(index);
    }

    return result;
  };

  var loadStyle = function loadStyle(href, document) {
    var link = document.createElement("link");
    link.type = "text/css";
    link.rel = "stylesheet";
    link.href = href;
    return link;
  };
  var injectStyle = function injectStyle(css, document) {
    var style = document.createElement("style");
    style.type = "text/css";
    style.appendChild(document.createTextNode(css));
    document.head.appendChild(style);
    return style;
  };

  var newEvent$1 = function newEvent(_ref) {
    var event = _ref.event,
        _ref$bubbles = _ref.bubbles,
        bubbles = _ref$bubbles === void 0 ? true : _ref$bubbles,
        _ref$cancelable = _ref.cancelable,
        cancelable = _ref$cancelable === void 0 ? true : _ref$cancelable;
    if (typeof window.Event === "function") return new window.Event(event, {
      bubbles: bubbles,
      cancelable: cancelable
    });
    var e = document.createEvent("Event");
    e.initEvent(event, bubbles, cancelable);
    return e;
  };
  var trigger$1 = function trigger(e, event) {
    return e.dispatchEvent(newEvent$1({
      event: event
    }));
  };

  var isSelect$1 = function isSelect(e) {
    if (e === null) return false;
    return e instanceof HTMLSelectElement;
  };
  var isInput$1 = function isInput(e) {
    if (e === null) return false;
    return e instanceof HTMLInputElement;
  };
  var isTextarea$1 = function isTextarea(e) {
    if (e === null) return false;
    return e instanceof HTMLTextAreaElement;
  };
  var update$1 = function update(input, value) {
    var skipTrigger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (!input) return;
    if (!isInput$1(input) && !isTextarea$1(input)) return;
    change$1({
      e: input,
      value: value,
      skipTrigger: skipTrigger
    });
  };
  var hasValue$1 = function hasValue(select, value) {
    if (value === null) return false;
    return select.querySelector("[value=\"".concat(value, "\"]")) !== null;
  };

  var updateSelect$1 = function updateSelect(_ref) {
    var e = _ref.e,
        value = _ref.value,
        skipTrigger = _ref.skipTrigger;
    if (value === null) return;
    if (!isSelect$1(e)) return;
    setValue$1(e, value);
    if (!skipTrigger) trigger$1(e, "select");
    trigger$1(e, "change");
  };

  var setValue$1 = function setValue(e, value) {
    var descriptor = Object.getOwnPropertyDescriptor(e.constructor.prototype, "value");
    if (descriptor === undefined) return;
    if (descriptor.set === undefined) return;
    var setter = descriptor.set;
    setter.call(e, value);
  };

  var updateInput$1 = function updateInput(_ref2) {
    var e = _ref2.e,
        value = _ref2.value,
        skipTrigger = _ref2.skipTrigger;
    if (value === null) return;
    if (!isInput$1(e) && !isTextarea$1(e)) return;
    setValue$1(e, value);
    if (!skipTrigger) trigger$1(e, "input");
    trigger$1(e, "change");
  };

  var change$1 = function change(options) {
    if (options.value === null) return;
    updateSelect$1(options);
    updateInput$1(options);
  };

  var toCiIso$1 = function toCiIso(address) {
    if (/^GY/.test(address.postcode)) return "GG";
    if (/^JE/.test(address.postcode)) return "JE";
    return null;
  };
  var UK = "United Kingdom";
  var IOM$1 = "Isle of Man";
  var EN$1 = "England";
  var SC$1 = "Scotland";
  var WA$1 = "Wales";
  var NI$1 = "Northern Ireland";
  var CI$1 = "Channel Islands";
  var toIso$1 = function toIso(address) {
    var country = address.country;
    if (country === EN$1) return "GB";
    if (country === SC$1) return "GB";
    if (country === WA$1) return "GB";
    if (country === NI$1) return "GB";
    if (country === IOM$1) return "IM";
    if (country === CI$1) return toCiIso$1(address);
    return null;
  };
  var toCountry = function toCountry(address) {
    var country = address.country;
    if (country === EN$1) return UK;
    if (country === SC$1) return UK;
    if (country === WA$1) return UK;
    if (country === NI$1) return UK;
    if (country === IOM$1) return IOM$1;

    if (country === CI$1) {
      var iso = toCiIso$1(address);
      if (iso === "GG") return "Guernsey";
      if (iso === "JE") return "Jersey";
    }

    return null;
  };
  var updateCountry = function updateCountry(select, address) {
    if (!select) return;

    if (isSelect$1(select)) {
      var iso = toIso$1(address);
      if (hasValue$1(select, iso)) change$1({
        e: select,
        value: iso
      });
      var bcc = toCountry(address);
      if (hasValue$1(select, bcc)) change$1({
        e: select,
        value: bcc
      });
    }

    if (isInput$1(select)) {
      var _bcc = toCountry(address);

      change$1({
        e: select,
        value: _bcc
      });
    }
  };

  var g$1 = {};

  if (hasWindow$1()) {
    if (window.idpcGlobal) {
      g$1 = window.idpcGlobal;
    } else {
      window.idpcGlobal = g$1;
    }
  }

  var idpcState = function idpcState() {
    return g$1;
  };

  var idGen = function idGen() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "idpc_";
    return function () {
      var g = idpcState();
      if (!g.idGen) g.idGen = {};
      if (g.idGen[prefix] === undefined) g.idGen[prefix] = 0;
      g.idGen[prefix] += 1;
      return "".concat(prefix).concat(g.idGen[prefix]);
    };
  };

  var dist = {};

  Object.defineProperty(dist, "__esModule", {
    value: true
  });
  var capitalisePostTown_1 = dist.capitalisePostTown = void 0;
  var exclusion = /^(of|le|upon|on|the)$/;
  var containsAmpersand = /\w+&\w+/; // capitalise word with exceptions on exclusion list

  var capitaliseWord = function capitaliseWord(word) {
    word = word.toLowerCase();
    if (word.match(exclusion)) return word;
    if (word.match(containsAmpersand)) return word.toUpperCase();
    return word.charAt(0).toUpperCase() + word.slice(1);
  };

  var joiner = /-/;
  var joinerWord = /^(in|de|under|upon|y|on|over|the|by)$/; // Check for names connected with hyphens

  var checkJoins = function checkJoins(string) {
    if (string.match(joiner) === null) return string;
    return string.split("-").map(function (str) {
      if (str.match(joinerWord)) return str.toLowerCase();
      return capitaliseWord(str);
    }).join("-");
  };

  var boness = /bo'ness/i;
  var bfpo = /bfpo/i; // Handles unusual names which cannot be easily generalised into a rule

  var exceptions = function exceptions(str) {
    if (str.match(boness)) return "Bo'Ness";
    if (str.match(bfpo)) return "BFPO";
    return str;
  };

  var capitalisePostTown = function capitalisePostTown(postTown) {
    return postTown.split(" ").map(capitaliseWord).map(checkJoins).map(exceptions).join(" ");
  };

  capitalisePostTown_1 = dist.capitalisePostTown = capitalisePostTown;

  function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var numberOfLines = function numberOfLines(targets) {
    var line_2 = targets.line_2,
        line_3 = targets.line_3;
    if (!line_2) return 1;
    if (!line_3) return 2;
    return 3;
  };
  var join = function join(list) {
    return list.filter(function (e) {
      if (isString(e)) return !!e.trim();
      return !!e;
    }).join(", ");
  };
  var toAddressLines = function toAddressLines(n, address) {
    var line_1 = address.line_1,
        line_2 = address.line_2,
        line_3 = address.line_3;
    if (n === 3) return [line_1, line_2, line_3];
    if (n === 2) return [line_1, join([line_2, line_3]), ""];
    return [join([line_1, line_2, line_3]), "", ""];
  };
  var extract = function extract(a, attr) {
    var result = a[attr];
    if (typeof result === "number") return result.toString();
    if (result === undefined) return "";
    return result;
  };
  var notInAddress = function notInAddress(o, attr) {
    return o[attr] === undefined;
  };
  var getFields = function getFields(o) {
    return _objectSpread$4(_objectSpread$4(_objectSpread$4({}, o.outputFields), searchNames(o.names || {}, o.config.scope)), searchLabels(o.labels || {}, o.config.scope));
  };

  var updateLines = function updateLines(fields, address, scope) {
    var _toAddressLines3 = toAddressLines(numberOfLines(fields), address),
        _toAddressLines4 = _slicedToArray(_toAddressLines3, 3),
        line_1 = _toAddressLines4[0],
        line_2 = _toAddressLines4[1],
        line_3 = _toAddressLines4[2];

    update$1(toElem(fields.line_1 || null, scope), line_1);
    update$1(toElem(fields.line_2 || null, scope), line_2);
    update$1(toElem(fields.line_3 || null, scope), line_3);
  };

  var searchNames = function searchNames(names, scope) {
    var result = {};
    var key;

    for (key in names) {
      if (!names.hasOwnProperty(key)) continue;
      var name = names[key];
      var named = toElem("[name=\"".concat(name, "\"]"), scope);

      if (named) {
        result[key] = named;
        continue;
      }

      var ariaNamed = toElem("[aria-name=\"".concat(name, "\"]"), scope);
      if (ariaNamed) result[key] = ariaNamed;
    }

    return result;
  };
  var searchLabels = function searchLabels(labels, scope) {
    var result = {};
    if (labels === undefined) return labels;
    var key;

    for (key in labels) {
      if (!labels.hasOwnProperty(key)) continue;
      var name = labels[key];
      if (!name) continue;
      var first = contains(scope, "label", name);
      var label = toElem(first, scope);
      if (!label) continue;
      var forEl = label.getAttribute("for");

      if (forEl) {
        var byId = scope.querySelector("#".concat(cssEscape(forEl)));

        if (byId) {
          result[key] = byId;
          continue;
        }
      }

      var inner = label.querySelector("input");
      if (inner) result[key] = inner;
    }

    return result;
  };
  var populateAddress = function populateAddress(options) {
    var config = options.config;

    var address = _objectSpread$4({}, options.address);

    var scope = config.scope,
        titleizePostTown = config.titleizePostTown,
        populateOrganisation = config.populateOrganisation,
        populateCounty = config.populateCounty;
    var fields = getFields(options);
    if (config.removeOrganisation) removeOrganisation(address);
    if (titleizePostTown) address.post_town = capitalisePostTown_1(address.post_town);
    updateLines(fields, address, scope);
    delete address.line_1;
    delete address.line_2;
    delete address.line_3;
    updateCountry(toElem(fields.country || null, scope), address);
    delete address.country;
    if (populateOrganisation === false) delete address.organisation_name;
    if (populateCounty === false) delete address.county;
    var e;

    for (e in fields) {
      if (notInAddress(address, e)) continue;

      if (fields.hasOwnProperty(e)) {
        var value = fields[e];
        if (!value) continue;
        update$1(toElem(value, scope), extract(address, e));
      }
    }
  };
  var removeOrganisation = function removeOrganisation(address) {
    if (address.organisation_name.length === 0) return address;
    if (address.line_2.length === 0 && address.line_3.length === 0) return address;

    if (address.line_1 === address.organisation_name) {
      address.line_1 = address.line_2;
      address.line_2 = address.line_3;
      address.line_3 = "";
    }

    return address;
  };

  var keyCodeMapping = {
    13: "Enter",
    38: "ArrowUp",
    40: "ArrowDown",
    36: "Home",
    35: "End",
    27: "Escape",
    8: "Backspace"
  };
  var supportedKeys = ["Enter", "ArrowUp", "ArrowDown", "Home", "End", "Escape", "Backspace"];

  var supported = function supported(k) {
    return supportedKeys.indexOf(k) !== -1;
  };

  var toKey = function toKey(event) {
    if (event.keyCode) return keyCodeMapping[event.keyCode] || null;
    return supported(event.key) ? event.key : null;
  };

  var check = function check(it) {
    return it && it.Math == Math && it;
  }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


  var global$c = // eslint-disable-next-line es/no-global-this -- safe
  check((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) == 'object' && globalThis) || check((typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check((typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self) || check(_typeof(commonjsGlobal) == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  function () {
    return this;
  }() || Function('return this')();

  // https://tc39.es/ecma262/#sec-iscallable

  var isCallable$g = function isCallable(argument) {
    return typeof argument === 'function';
  };

  var objectGetOwnPropertyDescriptor = {};

  var fails$b = function fails(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  var fails$a = fails$b; // Detect IE8's incomplete defineProperty implementation

  var descriptors = !fails$a(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({}, 1, {
      get: function get() {
        return 7;
      }
    })[1] != 7;
  });

  var objectPropertyIsEnumerable = {};

  var $propertyIsEnumerable = {}.propertyIsEnumerable; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

  var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({
    1: 2
  }, 1); // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor$1(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;

  var createPropertyDescriptor$3 = function createPropertyDescriptor(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var toString$5 = {}.toString;

  var classofRaw$1 = function classofRaw(it) {
    return toString$5.call(it).slice(8, -1);
  };

  var fails$9 = fails$b;
  var classof$7 = classofRaw$1;
  var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

  var indexedObject = fails$9(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !Object('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classof$7(it) == 'String' ? split.call(it, '') : Object(it);
  } : Object;

  // https://tc39.es/ecma262/#sec-requireobjectcoercible

  var requireObjectCoercible$3 = function requireObjectCoercible(it) {
    if (it == undefined) throw TypeError("Can't call method on " + it);
    return it;
  };

  var IndexedObject$2 = indexedObject;
  var requireObjectCoercible$2 = requireObjectCoercible$3;

  var toIndexedObject$5 = function toIndexedObject(it) {
    return IndexedObject$2(requireObjectCoercible$2(it));
  };

  var isCallable$f = isCallable$g;

  var isObject$b = function isObject(it) {
    return _typeof(it) === 'object' ? it !== null : isCallable$f(it);
  };

  var path$4 = {};

  var path$3 = path$4;
  var global$b = global$c;
  var isCallable$e = isCallable$g;

  var aFunction = function aFunction(variable) {
    return isCallable$e(variable) ? variable : undefined;
  };

  var getBuiltIn$c = function getBuiltIn(namespace, method) {
    return arguments.length < 2 ? aFunction(path$3[namespace]) || aFunction(global$b[namespace]) : path$3[namespace] && path$3[namespace][method] || global$b[namespace] && global$b[namespace][method];
  };

  var getBuiltIn$b = getBuiltIn$c;
  var engineUserAgent = getBuiltIn$b('navigator', 'userAgent') || '';

  var global$a = global$c;
  var userAgent = engineUserAgent;
  var process$1 = global$a.process;
  var Deno = global$a.Deno;
  var versions = process$1 && process$1.versions || Deno && Deno.version;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.');
    version = match[0] < 4 ? 1 : match[0] + match[1];
  } else if (userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);

    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match) version = match[1];
    }
  }

  var engineV8Version = version && +version;

  /* eslint-disable es/no-symbol -- required for testing */
  var V8_VERSION = engineV8Version;
  var fails$8 = fails$b; // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing

  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$8(function () {
    var symbol = Symbol(); // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances

    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  });

  var NATIVE_SYMBOL$1 = nativeSymbol;
  var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && _typeof(Symbol.iterator) == 'symbol';

  var isCallable$d = isCallable$g;
  var getBuiltIn$a = getBuiltIn$c;
  var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
  var isSymbol$4 = USE_SYMBOL_AS_UID$1 ? function (it) {
    return _typeof(it) == 'symbol';
  } : function (it) {
    var $Symbol = getBuiltIn$a('Symbol');
    return isCallable$d($Symbol) && Object(it) instanceof $Symbol;
  };

  var tryToString$2 = function tryToString(argument) {
    try {
      return String(argument);
    } catch (error) {
      return 'Object';
    }
  };

  var isCallable$c = isCallable$g;
  var tryToString$1 = tryToString$2; // `Assert: IsCallable(argument) is true`

  var aCallable$g = function aCallable(argument) {
    if (isCallable$c(argument)) return argument;
    throw TypeError(tryToString$1(argument) + ' is not a function');
  };

  var aCallable$f = aCallable$g; // `GetMethod` abstract operation
  // https://tc39.es/ecma262/#sec-getmethod

  var getMethod$3 = function getMethod(V, P) {
    var func = V[P];
    return func == null ? undefined : aCallable$f(func);
  };

  var isCallable$b = isCallable$g;
  var isObject$a = isObject$b; // `OrdinaryToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-ordinarytoprimitive

  var ordinaryToPrimitive$1 = function ordinaryToPrimitive(input, pref) {
    var fn, val;
    if (pref === 'string' && isCallable$b(fn = input.toString) && !isObject$a(val = fn.call(input))) return val;
    if (isCallable$b(fn = input.valueOf) && !isObject$a(val = fn.call(input))) return val;
    if (pref !== 'string' && isCallable$b(fn = input.toString) && !isObject$a(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var shared$3 = {exports: {}};

  var isPure = true;

  var global$9 = global$c;

  var setGlobal$1 = function setGlobal(key, value) {
    try {
      // eslint-disable-next-line es/no-object-defineproperty -- safe
      Object.defineProperty(global$9, key, {
        value: value,
        configurable: true,
        writable: true
      });
    } catch (error) {
      global$9[key] = value;
    }

    return value;
  };

  var global$8 = global$c;
  var setGlobal = setGlobal$1;
  var SHARED = '__core-js_shared__';
  var store$3 = global$8[SHARED] || setGlobal(SHARED, {});
  var sharedStore = store$3;

  var store$2 = sharedStore;
  (shared$3.exports = function (key, value) {
    return store$2[key] || (store$2[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.18.2',
    mode: 'pure' ,
    copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
  });

  var requireObjectCoercible$1 = requireObjectCoercible$3; // `ToObject` abstract operation
  // https://tc39.es/ecma262/#sec-toobject

  var toObject$4 = function toObject(argument) {
    return Object(requireObjectCoercible$1(argument));
  };

  var toObject$3 = toObject$4;
  var hasOwnProperty$1 = {}.hasOwnProperty; // `HasOwnProperty` abstract operation
  // https://tc39.es/ecma262/#sec-hasownproperty

  var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty$1.call(toObject$3(it), key);
  };

  var id$1 = 0;
  var postfix = Math.random();

  var uid$3 = function uid(key) {
    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id$1 + postfix).toString(36);
  };

  var global$7 = global$c;
  var shared$2 = shared$3.exports;
  var hasOwn$8 = hasOwnProperty_1;
  var uid$2 = uid$3;
  var NATIVE_SYMBOL = nativeSymbol;
  var USE_SYMBOL_AS_UID = useSymbolAsUid;
  var WellKnownSymbolsStore = shared$2('wks');
  var _Symbol$3 = global$7.Symbol;
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? _Symbol$3 : _Symbol$3 && _Symbol$3.withoutSetter || uid$2;

  var wellKnownSymbol$c = function wellKnownSymbol(name) {
    if (!hasOwn$8(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
      if (NATIVE_SYMBOL && hasOwn$8(_Symbol$3, name)) {
        WellKnownSymbolsStore[name] = _Symbol$3[name];
      } else {
        WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
      }
    }

    return WellKnownSymbolsStore[name];
  };

  var isObject$9 = isObject$b;
  var isSymbol$3 = isSymbol$4;
  var getMethod$2 = getMethod$3;
  var ordinaryToPrimitive = ordinaryToPrimitive$1;
  var wellKnownSymbol$b = wellKnownSymbol$c;
  var TO_PRIMITIVE = wellKnownSymbol$b('toPrimitive'); // `ToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-toprimitive

  var toPrimitive$1 = function toPrimitive(input, pref) {
    if (!isObject$9(input) || isSymbol$3(input)) return input;
    var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);
    var result;

    if (exoticToPrim) {
      if (pref === undefined) pref = 'default';
      result = exoticToPrim.call(input, pref);
      if (!isObject$9(result) || isSymbol$3(result)) return result;
      throw TypeError("Can't convert object to primitive value");
    }

    if (pref === undefined) pref = 'number';
    return ordinaryToPrimitive(input, pref);
  };

  var toPrimitive = toPrimitive$1;
  var isSymbol$2 = isSymbol$4; // `ToPropertyKey` abstract operation
  // https://tc39.es/ecma262/#sec-topropertykey

  var toPropertyKey$2 = function toPropertyKey(argument) {
    var key = toPrimitive(argument, 'string');
    return isSymbol$2(key) ? key : String(key);
  };

  var global$6 = global$c;
  var isObject$8 = isObject$b;
  var document$1 = global$6.document; // typeof document.createElement is 'object' in old IE

  var EXISTS$1 = isObject$8(document$1) && isObject$8(document$1.createElement);

  var documentCreateElement$1 = function documentCreateElement(it) {
    return EXISTS$1 ? document$1.createElement(it) : {};
  };

  var DESCRIPTORS$9 = descriptors;
  var fails$7 = fails$b;
  var createElement = documentCreateElement$1; // Thank's IE8 for his funny defineProperty

  var ie8DomDefine = !DESCRIPTORS$9 && !fails$7(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
    return Object.defineProperty(createElement('div'), 'a', {
      get: function get() {
        return 7;
      }
    }).a != 7;
  });

  var DESCRIPTORS$8 = descriptors;
  var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
  var createPropertyDescriptor$2 = createPropertyDescriptor$3;
  var toIndexedObject$4 = toIndexedObject$5;
  var toPropertyKey$1 = toPropertyKey$2;
  var hasOwn$7 = hasOwnProperty_1;
  var IE8_DOM_DEFINE$1 = ie8DomDefine; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

  objectGetOwnPropertyDescriptor.f = DESCRIPTORS$8 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject$4(O);
    P = toPropertyKey$1(P);
    if (IE8_DOM_DEFINE$1) try {
      return $getOwnPropertyDescriptor(O, P);
    } catch (error) {
      /* empty */
    }
    if (hasOwn$7(O, P)) return createPropertyDescriptor$2(!propertyIsEnumerableModule$1.f.call(O, P), O[P]);
  };

  var fails$6 = fails$b;
  var isCallable$a = isCallable$g;
  var replacement = /#|\.prototype\./;

  var isForced$1 = function isForced(feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true : value == NATIVE ? false : isCallable$a(detection) ? fails$6(detection) : !!detection;
  };

  var normalize = isForced$1.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced$1.data = {};
  var NATIVE = isForced$1.NATIVE = 'N';
  var POLYFILL = isForced$1.POLYFILL = 'P';
  var isForced_1 = isForced$1;

  var aCallable$e = aCallable$g; // optional / simple context binding

  var functionBindContext = function functionBindContext(fn, that, length) {
    aCallable$e(fn);
    if (that === undefined) return fn;

    switch (length) {
      case 0:
        return function () {
          return fn.call(that);
        };

      case 1:
        return function (a) {
          return fn.call(that, a);
        };

      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };

      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }

    return function () {
      return fn.apply(that, arguments);
    };
  };

  var objectDefineProperty = {};

  var isObject$7 = isObject$b; // `Assert: Type(argument) is Object`

  var anObject$o = function anObject(argument) {
    if (isObject$7(argument)) return argument;
    throw TypeError(String(argument) + ' is not an object');
  };

  var DESCRIPTORS$7 = descriptors;
  var IE8_DOM_DEFINE = ie8DomDefine;
  var anObject$n = anObject$o;
  var toPropertyKey = toPropertyKey$2; // eslint-disable-next-line es/no-object-defineproperty -- safe

  var $defineProperty = Object.defineProperty; // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty

  objectDefineProperty.f = DESCRIPTORS$7 ? $defineProperty : function defineProperty(O, P, Attributes) {
    anObject$n(O);
    P = toPropertyKey(P);
    anObject$n(Attributes);
    if (IE8_DOM_DEFINE) try {
      return $defineProperty(O, P, Attributes);
    } catch (error) {
      /* empty */
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var DESCRIPTORS$6 = descriptors;
  var definePropertyModule$2 = objectDefineProperty;
  var createPropertyDescriptor$1 = createPropertyDescriptor$3;
  var createNonEnumerableProperty$6 = DESCRIPTORS$6 ? function (object, key, value) {
    return definePropertyModule$2.f(object, key, createPropertyDescriptor$1(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var global$5 = global$c;
  var isCallable$9 = isCallable$g;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var isForced = isForced_1;
  var path$2 = path$4;
  var bind$9 = functionBindContext;
  var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
  var hasOwn$6 = hasOwnProperty_1;

  var wrapConstructor = function wrapConstructor(NativeConstructor) {
    var Wrapper = function Wrapper(a, b, c) {
      if (this instanceof NativeConstructor) {
        switch (arguments.length) {
          case 0:
            return new NativeConstructor();

          case 1:
            return new NativeConstructor(a);

          case 2:
            return new NativeConstructor(a, b);
        }

        return new NativeConstructor(a, b, c);
      }

      return NativeConstructor.apply(this, arguments);
    };

    Wrapper.prototype = NativeConstructor.prototype;
    return Wrapper;
  };
  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
    options.name        - the .name of the function if it does not match the key
  */


  var _export = function _export(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var PROTO = options.proto;
    var nativeSource = GLOBAL ? global$5 : STATIC ? global$5[TARGET] : (global$5[TARGET] || {}).prototype;
    var target = GLOBAL ? path$2 : path$2[TARGET] || createNonEnumerableProperty$5(path$2, TARGET, {})[TARGET];
    var targetPrototype = target.prototype;
    var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
    var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

    for (key in source) {
      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contains in native

      USE_NATIVE = !FORCED && nativeSource && hasOwn$6(nativeSource, key);
      targetProperty = target[key];
      if (USE_NATIVE) if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor(nativeSource, key);
        nativeProperty = descriptor && descriptor.value;
      } else nativeProperty = nativeSource[key]; // export native or implementation

      sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
      if (USE_NATIVE && _typeof(targetProperty) === _typeof(sourceProperty)) continue; // bind timers to global for call from export context

      if (options.bind && USE_NATIVE) resultProperty = bind$9(sourceProperty, global$5); // wrap global constructors for prevent changs in this version
      else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty); // make static versions for prototype methods
      else if (PROTO && isCallable$9(sourceProperty)) resultProperty = bind$9(Function.call, sourceProperty); // default case
      else resultProperty = sourceProperty; // add a flag to not completely full polyfills

      if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$5(resultProperty, 'sham', true);
      }

      createNonEnumerableProperty$5(target, key, resultProperty);

      if (PROTO) {
        VIRTUAL_PROTOTYPE = TARGET + 'Prototype';

        if (!hasOwn$6(path$2, VIRTUAL_PROTOTYPE)) {
          createNonEnumerableProperty$5(path$2, VIRTUAL_PROTOTYPE, {});
        } // export virtual prototype methods


        createNonEnumerableProperty$5(path$2[VIRTUAL_PROTOTYPE], key, sourceProperty); // export real prototype methods

        if (options.real && targetPrototype && !targetPrototype[key]) {
          createNonEnumerableProperty$5(targetPrototype, key, sourceProperty);
        }
      }
    }
  };

  var ceil = Math.ceil;
  var floor = Math.floor; // `ToIntegerOrInfinity` abstract operation
  // https://tc39.es/ecma262/#sec-tointegerorinfinity

  var toIntegerOrInfinity$3 = function toIntegerOrInfinity(argument) {
    var number = +argument; // eslint-disable-next-line no-self-compare -- safe

    return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
  };

  var toIntegerOrInfinity$2 = toIntegerOrInfinity$3;
  var max = Math.max;
  var min$1 = Math.min; // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

  var toAbsoluteIndex$1 = function toAbsoluteIndex(index, length) {
    var integer = toIntegerOrInfinity$2(index);
    return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
  };

  var toIntegerOrInfinity$1 = toIntegerOrInfinity$3;
  var min = Math.min; // `ToLength` abstract operation
  // https://tc39.es/ecma262/#sec-tolength

  var toLength$1 = function toLength(argument) {
    return argument > 0 ? min(toIntegerOrInfinity$1(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var toLength = toLength$1; // `LengthOfArrayLike` abstract operation
  // https://tc39.es/ecma262/#sec-lengthofarraylike

  var lengthOfArrayLike$3 = function lengthOfArrayLike(obj) {
    return toLength(obj.length);
  };

  var toIndexedObject$3 = toIndexedObject$5;
  var toAbsoluteIndex = toAbsoluteIndex$1;
  var lengthOfArrayLike$2 = lengthOfArrayLike$3; // `Array.prototype.{ indexOf, includes }` methods implementation

  var createMethod$2 = function createMethod(IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject$3($this);
      var length = lengthOfArrayLike$2(O);
      var index = toAbsoluteIndex(fromIndex, length);
      var value; // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare -- NaN check

      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
      } else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod$2(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$2(false)
  };

  var hiddenKeys$5 = {};

  var hasOwn$5 = hasOwnProperty_1;
  var toIndexedObject$2 = toIndexedObject$5;
  var indexOf = arrayIncludes.indexOf;
  var hiddenKeys$4 = hiddenKeys$5;

  var objectKeysInternal = function objectKeysInternal(object, names) {
    var O = toIndexedObject$2(object);
    var i = 0;
    var result = [];
    var key;

    for (key in O) {
      !hasOwn$5(hiddenKeys$4, key) && hasOwn$5(O, key) && result.push(key);
    } // Don't enum bug & hidden keys


    while (names.length > i) {
      if (hasOwn$5(O, key = names[i++])) {
        ~indexOf(result, key) || result.push(key);
      }
    }

    return result;
  };

  var enumBugKeys$3 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

  var internalObjectKeys$1 = objectKeysInternal;
  var enumBugKeys$2 = enumBugKeys$3; // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  // eslint-disable-next-line es/no-object-keys -- safe

  var objectKeys$2 = Object.keys || function keys(O) {
    return internalObjectKeys$1(O, enumBugKeys$2);
  };

  var objectGetOwnPropertySymbols = {};

  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

  var DESCRIPTORS$5 = descriptors;
  var fails$5 = fails$b;
  var objectKeys$1 = objectKeys$2;
  var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
  var propertyIsEnumerableModule = objectPropertyIsEnumerable;
  var toObject$2 = toObject$4;
  var IndexedObject$1 = indexedObject; // eslint-disable-next-line es/no-object-assign -- safe

  var $assign = $inject_Object_assign; // eslint-disable-next-line es/no-object-defineproperty -- required for testing

  var defineProperty$4 = Object.defineProperty; // `Object.assign` method
  // https://tc39.es/ecma262/#sec-object.assign

  var objectAssign = !$assign || fails$5(function () {
    // should have correct order of operations (Edge bug)
    if (DESCRIPTORS$5 && $assign({
      b: 1
    }, $assign(defineProperty$4({}, 'a', {
      enumerable: true,
      get: function get() {
        defineProperty$4(this, 'b', {
          value: 3,
          enumerable: false
        });
      }
    }), {
      b: 2
    })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

    var A = {};
    var B = {}; // eslint-disable-next-line es/no-symbol -- safe

    var symbol = Symbol();
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    alphabet.split('').forEach(function (chr) {
      B[chr] = chr;
    });
    return $assign({}, A)[symbol] != 7 || objectKeys$1($assign({}, B)).join('') != alphabet;
  }) ? function assign(target, source) {
    // eslint-disable-line no-unused-vars -- required for `.length`
    var T = toObject$2(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    var propertyIsEnumerable = propertyIsEnumerableModule.f;

    while (argumentsLength > index) {
      var S = IndexedObject$1(arguments[index++]);
      var keys = getOwnPropertySymbols ? objectKeys$1(S).concat(getOwnPropertySymbols(S)) : objectKeys$1(S);
      var length = keys.length;
      var j = 0;
      var key;

      while (length > j) {
        key = keys[j++];
        if (!DESCRIPTORS$5 || propertyIsEnumerable.call(S, key)) T[key] = S[key];
      }
    }

    return T;
  } : $assign;

  var $$l = _export;
  var assign$3 = objectAssign; // `Object.assign` method
  // https://tc39.es/ecma262/#sec-object.assign
  // eslint-disable-next-line es/no-object-assign -- required for testing

  $$l({
    target: 'Object',
    stat: true,
    forced: $inject_Object_assign !== assign$3
  }, {
    assign: assign$3
  });

  var path$1 = path$4;
  var assign$2 = path$1.Object.assign;

  var parent$3 = assign$2;
  var assign$1 = parent$3;

  var parent$2 = assign$1;
  var assign = parent$2;
  var $inject_Object_assign = assign;

  var iterators = {};

  var isCallable$8 = isCallable$g;
  var store$1 = sharedStore;
  var functionToString = Function.toString; // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper

  if (!isCallable$8(store$1.inspectSource)) {
    store$1.inspectSource = function (it) {
      return functionToString.call(it);
    };
  }

  var inspectSource$2 = store$1.inspectSource;

  var global$4 = global$c;
  var isCallable$7 = isCallable$g;
  var inspectSource$1 = inspectSource$2;
  var WeakMap$1 = global$4.WeakMap;
  var nativeWeakMap = isCallable$7(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));

  var shared$1 = shared$3.exports;
  var uid$1 = uid$3;
  var keys = shared$1('keys');

  var sharedKey$3 = function sharedKey(key) {
    return keys[key] || (keys[key] = uid$1(key));
  };

  var NATIVE_WEAK_MAP = nativeWeakMap;
  var global$3 = global$c;
  var isObject$6 = isObject$b;
  var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
  var hasOwn$4 = hasOwnProperty_1;
  var shared = sharedStore;
  var sharedKey$2 = sharedKey$3;
  var hiddenKeys$3 = hiddenKeys$5;
  var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
  var WeakMap = global$3.WeakMap;
  var set$3, get, has;

  var enforce = function enforce(it) {
    return has(it) ? get(it) : set$3(it, {});
  };

  var getterFor = function getterFor(TYPE) {
    return function (it) {
      var state;

      if (!isObject$6(it) || (state = get(it)).type !== TYPE) {
        throw TypeError('Incompatible receiver, ' + TYPE + ' required');
      }

      return state;
    };
  };

  if (NATIVE_WEAK_MAP || shared.state) {
    var store = shared.state || (shared.state = new WeakMap());
    var wmget = store.get;
    var wmhas = store.has;
    var wmset = store.set;

    set$3 = function set(it, metadata) {
      if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      wmset.call(store, it, metadata);
      return metadata;
    };

    get = function get(it) {
      return wmget.call(store, it) || {};
    };

    has = function has(it) {
      return wmhas.call(store, it);
    };
  } else {
    var STATE = sharedKey$2('state');
    hiddenKeys$3[STATE] = true;

    set$3 = function set(it, metadata) {
      if (hasOwn$4(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty$4(it, STATE, metadata);
      return metadata;
    };

    get = function get(it) {
      return hasOwn$4(it, STATE) ? it[STATE] : {};
    };

    has = function has(it) {
      return hasOwn$4(it, STATE);
    };
  }

  var internalState = {
    set: set$3,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
  };

  var DESCRIPTORS$4 = descriptors;
  var hasOwn$3 = hasOwnProperty_1;
  var FunctionPrototype = Function.prototype; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

  var getDescriptor = DESCRIPTORS$4 && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn$3(FunctionPrototype, 'name'); // additional protection from minified / mangled / dropped function names

  var PROPER = EXISTS && function something() {
    /* empty */
  }.name === 'something';

  var CONFIGURABLE = EXISTS && (!DESCRIPTORS$4 || DESCRIPTORS$4 && getDescriptor(FunctionPrototype, 'name').configurable);
  var functionName = {
    EXISTS: EXISTS,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE
  };

  var DESCRIPTORS$3 = descriptors;
  var definePropertyModule$1 = objectDefineProperty;
  var anObject$m = anObject$o;
  var objectKeys = objectKeys$2; // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  // eslint-disable-next-line es/no-object-defineproperties -- safe

  var objectDefineProperties = DESCRIPTORS$3 ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject$m(O);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;

    while (length > index) {
      definePropertyModule$1.f(O, key = keys[index++], Properties[key]);
    }

    return O;
  };

  var getBuiltIn$9 = getBuiltIn$c;
  var html$1 = getBuiltIn$9('document', 'documentElement');

  /* global ActiveXObject -- old IE, WSH */
  var anObject$l = anObject$o;
  var defineProperties = objectDefineProperties;
  var enumBugKeys$1 = enumBugKeys$3;
  var hiddenKeys$2 = hiddenKeys$5;
  var html = html$1;
  var documentCreateElement = documentCreateElement$1;
  var sharedKey$1 = sharedKey$3;
  var GT = '>';
  var LT = '<';
  var PROTOTYPE = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO$1 = sharedKey$1('IE_PROTO');

  var EmptyConstructor = function EmptyConstructor() {
    /* empty */
  };

  var scriptTag = function scriptTag(content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  }; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


  var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak

    return temp;
  }; // Create object with fake `null` prototype: use iframe Object with cleared prototype


  var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  }; // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug


  var activeXDocument;

  var _NullProtoObject = function NullProtoObject() {
    try {
      activeXDocument = new ActiveXObject('htmlfile');
    } catch (error) {
      /* ignore */
    }

    _NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
    : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH

    var length = enumBugKeys$1.length;

    while (length--) {
      delete _NullProtoObject[PROTOTYPE][enumBugKeys$1[length]];
    }

    return _NullProtoObject();
  };

  hiddenKeys$2[IE_PROTO$1] = true; // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create

  var objectCreate = Object.create || function create(O, Properties) {
    var result;

    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject$l(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

      result[IE_PROTO$1] = O;
    } else result = _NullProtoObject();

    return Properties === undefined ? result : defineProperties(result, Properties);
  };

  var fails$4 = fails$b;
  var correctPrototypeGetter = !fails$4(function () {
    function F() {
      /* empty */
    }

    F.prototype.constructor = null; // eslint-disable-next-line es/no-object-getprototypeof -- required for testing

    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var hasOwn$2 = hasOwnProperty_1;
  var isCallable$6 = isCallable$g;
  var toObject$1 = toObject$4;
  var sharedKey = sharedKey$3;
  var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
  var IE_PROTO = sharedKey('IE_PROTO');
  var ObjectPrototype = Object.prototype; // `Object.getPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.getprototypeof
  // eslint-disable-next-line es/no-object-getprototypeof -- safe

  var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
    var object = toObject$1(O);
    if (hasOwn$2(object, IE_PROTO)) return object[IE_PROTO];
    var constructor = object.constructor;

    if (isCallable$6(constructor) && object instanceof constructor) {
      return constructor.prototype;
    }

    return object instanceof Object ? ObjectPrototype : null;
  };

  var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;

  var redefine$3 = function redefine(target, key, value, options) {
    if (options && options.enumerable) target[key] = value;else createNonEnumerableProperty$3(target, key, value);
  };

  var fails$3 = fails$b;
  var isCallable$5 = isCallable$g;
  var create$3 = objectCreate;
  var getPrototypeOf$1 = objectGetPrototypeOf;
  var redefine$2 = redefine$3;
  var wellKnownSymbol$a = wellKnownSymbol$c;
  var ITERATOR$3 = wellKnownSymbol$a('iterator');
  var BUGGY_SAFARI_ITERATORS$1 = false; // `%IteratorPrototype%` object
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-object

  var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;
  /* eslint-disable es/no-array-prototype-keys -- safe */

  if ([].keys) {
    arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
    }
  }

  var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$1 == undefined || fails$3(function () {
    var test = {}; // FF44- legacy iterators case

    return IteratorPrototype$1[ITERATOR$3].call(test) !== test;
  });
  if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};else IteratorPrototype$1 = create$3(IteratorPrototype$1); // `%IteratorPrototype%[@@iterator]()` method
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator

  if (!isCallable$5(IteratorPrototype$1[ITERATOR$3])) {
    redefine$2(IteratorPrototype$1, ITERATOR$3, function () {
      return this;
    });
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype$1,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
  };

  var wellKnownSymbol$9 = wellKnownSymbol$c;
  var TO_STRING_TAG$3 = wellKnownSymbol$9('toStringTag');
  var test = {};
  test[TO_STRING_TAG$3] = 'z';
  var toStringTagSupport = String(test) === '[object z]';

  var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
  var isCallable$4 = isCallable$g;
  var classofRaw = classofRaw$1;
  var wellKnownSymbol$8 = wellKnownSymbol$c;
  var TO_STRING_TAG$2 = wellKnownSymbol$8('toStringTag'); // ES3 wrong here

  var CORRECT_ARGUMENTS = classofRaw(function () {
    return arguments;
  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

  var tryGet = function tryGet(it, key) {
    try {
      return it[key];
    } catch (error) {
      /* empty */
    }
  }; // getting tag from ES6+ `Object.prototype.toString`


  var classof$6 = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable$4(O.callee) ? 'Arguments' : result;
  };

  var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
  var classof$5 = classof$6; // `Object.prototype.toString` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.tostring

  var objectToString$2 = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
    return '[object ' + classof$5(this) + ']';
  };

  var TO_STRING_TAG_SUPPORT = toStringTagSupport;
  var defineProperty$3 = objectDefineProperty.f;
  var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
  var hasOwn$1 = hasOwnProperty_1;
  var toString$4 = objectToString$2;
  var wellKnownSymbol$7 = wellKnownSymbol$c;
  var TO_STRING_TAG$1 = wellKnownSymbol$7('toStringTag');

  var setToStringTag$3 = function setToStringTag(it, TAG, STATIC, SET_METHOD) {
    if (it) {
      var target = STATIC ? it : it.prototype;

      if (!hasOwn$1(target, TO_STRING_TAG$1)) {
        defineProperty$3(target, TO_STRING_TAG$1, {
          configurable: true,
          value: TAG
        });
      }

      if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
        createNonEnumerableProperty$2(target, 'toString', toString$4);
      }
    }
  };

  var IteratorPrototype = iteratorsCore.IteratorPrototype;
  var create$2 = objectCreate;
  var createPropertyDescriptor = createPropertyDescriptor$3;
  var setToStringTag$2 = setToStringTag$3;
  var Iterators$5 = iterators;

  var returnThis$1 = function returnThis() {
    return this;
  };

  var createIteratorConstructor$1 = function createIteratorConstructor(IteratorConstructor, NAME, next) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = create$2(IteratorPrototype, {
      next: createPropertyDescriptor(1, next)
    });
    setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators$5[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
  };

  var isCallable$3 = isCallable$g;

  var aPossiblePrototype$1 = function aPossiblePrototype(argument) {
    if (_typeof(argument) === 'object' || isCallable$3(argument)) return argument;
    throw TypeError("Can't set " + String(argument) + ' as a prototype');
  };

  /* eslint-disable no-proto -- safe */
  var anObject$k = anObject$o;
  var aPossiblePrototype = aPossiblePrototype$1; // `Object.setPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  // eslint-disable-next-line es/no-object-setprototypeof -- safe

  Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;

    try {
      // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
      setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
      setter.call(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) {
      /* empty */
    }

    return function setPrototypeOf(O, proto) {
      anObject$k(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  var $$k = _export;
  var FunctionName = functionName;
  var createIteratorConstructor = createIteratorConstructor$1;
  var getPrototypeOf = objectGetPrototypeOf;
  var setToStringTag$1 = setToStringTag$3;
  var redefine$1 = redefine$3;
  var wellKnownSymbol$6 = wellKnownSymbol$c;
  var Iterators$4 = iterators;
  var IteratorsCore = iteratorsCore;
  var PROPER_FUNCTION_NAME = FunctionName.PROPER;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$2 = wellKnownSymbol$6('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis = function returnThis() {
    return this;
  };

  var defineIterator$3 = function defineIterator(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function getIterationMethod(KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

      switch (KIND) {
        case KEYS:
          return function keys() {
            return new IteratorConstructor(this, KIND);
          };

        case VALUES:
          return function values() {
            return new IteratorConstructor(this, KIND);
          };

        case ENTRIES:
          return function entries() {
            return new IteratorConstructor(this, KIND);
          };
      }

      return function () {
        return new IteratorConstructor(this);
      };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$2] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY; // fix native

    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));

      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {


        setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
        Iterators$4[TO_STRING_TAG] = returnThis;
      }
    } // fix Array.prototype.{ values, @@iterator }.name in V8 / FF


    if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      {
        INCORRECT_VALUES_NAME = true;

        defaultIterator = function values() {
          return nativeIterator.call(this);
        };
      }
    } // export additional methods


    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$1(IterablePrototype, KEY, methods[KEY]);
        }
      } else $$k({
        target: NAME,
        proto: true,
        forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
      }, methods);
    } // define iterator


    if ((FORCED) && IterablePrototype[ITERATOR$2] !== defaultIterator) {
      redefine$1(IterablePrototype, ITERATOR$2, defaultIterator, {
        name: DEFAULT
      });
    }

    Iterators$4[NAME] = defaultIterator;
    return methods;
  };

  var toIndexedObject$1 = toIndexedObject$5;
  var Iterators$3 = iterators;
  var InternalStateModule$3 = internalState;
  var defineIterator$2 = defineIterator$3;
  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState$3 = InternalStateModule$3.set;
  var getInternalState$1 = InternalStateModule$3.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
  // https://tc39.es/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.es/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.es/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.es/ecma262/#sec-createarrayiterator

  defineIterator$2(Array, 'Array', function (iterated, kind) {
    setInternalState$3(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject$1(iterated),
      // target
      index: 0,
      // next index
      kind: kind // kind

    }); // `%ArrayIteratorPrototype%.next` method
    // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState$1(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;

    if (!target || index >= target.length) {
      state.target = undefined;
      return {
        value: undefined,
        done: true
      };
    }

    if (kind == 'keys') return {
      value: index,
      done: false
    };
    if (kind == 'values') return {
      value: target[index],
      done: false
    };
    return {
      value: [index, target[index]],
      done: false
    };
  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.es/ecma262/#sec-createmappedargumentsobject

  Iterators$3.Arguments = Iterators$3.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

  var internalMetadata = {exports: {}};

  var objectGetOwnPropertyNames = {};

  var internalObjectKeys = objectKeysInternal;
  var enumBugKeys = enumBugKeys$3;
  var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  // eslint-disable-next-line es/no-object-getownpropertynames -- safe

  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys$1);
  };

  var objectGetOwnPropertyNamesExternal = {};

  var toIndexedObject = toIndexedObject$5;
  var $getOwnPropertyNames = objectGetOwnPropertyNames.f;
  var toString$3 = {}.toString;
  var windowNames = (typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function getWindowNames(it) {
    try {
      return $getOwnPropertyNames(it);
    } catch (error) {
      return windowNames.slice();
    }
  }; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


  objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
    return windowNames && toString$3.call(it) == '[object Window]' ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
  };

  var fails$2 = fails$b;
  var freezing = !fails$2(function () {
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
    return Object.isExtensible(Object.preventExtensions({}));
  });

  var $$j = _export;
  var hiddenKeys = hiddenKeys$5;
  var isObject$5 = isObject$b;
  var hasOwn = hasOwnProperty_1;
  var defineProperty$2 = objectDefineProperty.f;
  var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
  var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
  var uid = uid$3;
  var FREEZING = freezing;
  var REQUIRED = false;
  var METADATA = uid('meta');
  var id = 0; // eslint-disable-next-line es/no-object-isextensible -- safe

  var isExtensible = Object.isExtensible || function () {
    return true;
  };

  var setMetadata = function setMetadata(it) {
    defineProperty$2(it, METADATA, {
      value: {
        objectID: 'O' + id++,
        // object ID
        weakData: {} // weak collections IDs

      }
    });
  };

  var fastKey$1 = function fastKey(it, create) {
    // return a primitive with prefix
    if (!isObject$5(it)) return _typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

    if (!hasOwn(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F'; // not necessary to add metadata

      if (!create) return 'E'; // add missing metadata

      setMetadata(it); // return object ID
    }

    return it[METADATA].objectID;
  };

  var getWeakData = function getWeakData(it, create) {
    if (!hasOwn(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true; // not necessary to add metadata

      if (!create) return false; // add missing metadata

      setMetadata(it); // return the store of weak collections IDs
    }

    return it[METADATA].weakData;
  }; // add metadata on freeze-family methods calling


  var onFreeze = function onFreeze(it) {
    if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
    return it;
  };

  var enable = function enable() {
    meta.enable = function () {
      /* empty */
    };

    REQUIRED = true;
    var getOwnPropertyNames = getOwnPropertyNamesModule.f;
    var splice = [].splice;
    var test = {};
    test[METADATA] = 1; // prevent exposing of metadata key

    if (getOwnPropertyNames(test).length) {
      getOwnPropertyNamesModule.f = function (it) {
        var result = getOwnPropertyNames(it);

        for (var i = 0, length = result.length; i < length; i++) {
          if (result[i] === METADATA) {
            splice.call(result, i, 1);
            break;
          }
        }

        return result;
      };

      $$j({
        target: 'Object',
        stat: true,
        forced: true
      }, {
        getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
      });
    }
  };

  var meta = internalMetadata.exports = {
    enable: enable,
    fastKey: fastKey$1,
    getWeakData: getWeakData,
    onFreeze: onFreeze
  };
  hiddenKeys[METADATA] = true;

  var wellKnownSymbol$5 = wellKnownSymbol$c;
  var Iterators$2 = iterators;
  var ITERATOR$1 = wellKnownSymbol$5('iterator');
  var ArrayPrototype = Array.prototype; // check on default Array iterator

  var isArrayIteratorMethod$1 = function isArrayIteratorMethod(it) {
    return it !== undefined && (Iterators$2.Array === it || ArrayPrototype[ITERATOR$1] === it);
  };

  var classof$4 = classof$6;
  var getMethod$1 = getMethod$3;
  var Iterators$1 = iterators;
  var wellKnownSymbol$4 = wellKnownSymbol$c;
  var ITERATOR = wellKnownSymbol$4('iterator');

  var getIteratorMethod$2 = function getIteratorMethod(it) {
    if (it != undefined) return getMethod$1(it, ITERATOR) || getMethod$1(it, '@@iterator') || Iterators$1[classof$4(it)];
  };

  var aCallable$d = aCallable$g;
  var anObject$j = anObject$o;
  var getIteratorMethod$1 = getIteratorMethod$2;

  var getIterator$3 = function getIterator(argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
    if (aCallable$d(iteratorMethod)) return anObject$j(iteratorMethod.call(argument));
    throw TypeError(String(argument) + ' is not iterable');
  };

  var anObject$i = anObject$o;
  var getMethod = getMethod$3;

  var iteratorClose$1 = function iteratorClose(iterator, kind, value) {
    var innerResult, innerError;
    anObject$i(iterator);

    try {
      innerResult = getMethod(iterator, 'return');

      if (!innerResult) {
        if (kind === 'throw') throw value;
        return value;
      }

      innerResult = innerResult.call(iterator);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }

    if (kind === 'throw') throw value;
    if (innerError) throw innerResult;
    anObject$i(innerResult);
    return value;
  };

  var anObject$h = anObject$o;
  var isArrayIteratorMethod = isArrayIteratorMethod$1;
  var lengthOfArrayLike$1 = lengthOfArrayLike$3;
  var bind$8 = functionBindContext;
  var getIterator$2 = getIterator$3;
  var getIteratorMethod = getIteratorMethod$2;
  var iteratorClose = iteratorClose$1;

  var Result = function Result(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var iterate$h = function iterate(iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind$8(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
    var iterator, iterFn, index, length, result, next, step;

    var stop = function stop(condition) {
      if (iterator) iteratorClose(iterator, 'normal', condition);
      return new Result(true, condition);
    };

    var callFn = function callFn(value) {
      if (AS_ENTRIES) {
        anObject$h(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      }

      return INTERRUPTED ? fn(value, stop) : fn(value);
    };

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (!iterFn) throw TypeError(String(iterable) + ' is not iterable'); // optimisation for array iterators

      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = lengthOfArrayLike$1(iterable); length > index; index++) {
          result = callFn(iterable[index]);
          if (result && result instanceof Result) return result;
        }

        return new Result(false);
      }

      iterator = getIterator$2(iterable, iterFn);
    }

    next = iterator.next;

    while (!(step = next.call(iterator)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose(iterator, 'throw', error);
      }

      if (_typeof(result) == 'object' && result && result instanceof Result) return result;
    }

    return new Result(false);
  };

  var anInstance$2 = function anInstance(it, Constructor, name) {
    if (it instanceof Constructor) return it;
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  };

  var classof$3 = classofRaw$1; // `IsArray` abstract operation
  // https://tc39.es/ecma262/#sec-isarray
  // eslint-disable-next-line es/no-array-isarray -- safe

  var isArray$1 = Array.isArray || function isArray(argument) {
    return classof$3(argument) == 'Array';
  };

  var fails$1 = fails$b;
  var isCallable$2 = isCallable$g;
  var classof$2 = classof$6;
  var getBuiltIn$8 = getBuiltIn$c;
  var inspectSource = inspectSource$2;
  var empty = [];
  var construct = getBuiltIn$8('Reflect', 'construct');
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec = constructorRegExp.exec;
  var INCORRECT_TO_STRING = !constructorRegExp.exec(function () {
    /* empty */
  });

  var isConstructorModern = function isConstructorModern(argument) {
    if (!isCallable$2(argument)) return false;

    try {
      construct(Object, empty, argument);
      return true;
    } catch (error) {
      return false;
    }
  };

  var isConstructorLegacy = function isConstructorLegacy(argument) {
    if (!isCallable$2(argument)) return false;

    switch (classof$2(argument)) {
      case 'AsyncFunction':
      case 'GeneratorFunction':
      case 'AsyncGeneratorFunction':
        return false;
      // we can't check .prototype since constructors produced by .bind haven't it
    }

    return INCORRECT_TO_STRING || !!exec.call(constructorRegExp, inspectSource(argument));
  }; // `IsConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-isconstructor


  var isConstructor$2 = !construct || fails$1(function () {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
      called = true;
    }) || called;
  }) ? isConstructorLegacy : isConstructorModern;

  var isArray = isArray$1;
  var isConstructor$1 = isConstructor$2;
  var isObject$4 = isObject$b;
  var wellKnownSymbol$3 = wellKnownSymbol$c;
  var SPECIES$2 = wellKnownSymbol$3('species'); // a part of `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate

  var arraySpeciesConstructor$1 = function arraySpeciesConstructor(originalArray) {
    var C;

    if (isArray(originalArray)) {
      C = originalArray.constructor; // cross-realm fallback

      if (isConstructor$1(C) && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject$4(C)) {
        C = C[SPECIES$2];
        if (C === null) C = undefined;
      }
    }

    return C === undefined ? Array : C;
  };

  var arraySpeciesConstructor = arraySpeciesConstructor$1; // `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate

  var arraySpeciesCreate$1 = function arraySpeciesCreate(originalArray, length) {
    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
  };

  var bind$7 = functionBindContext;
  var IndexedObject = indexedObject;
  var toObject = toObject$4;
  var lengthOfArrayLike = lengthOfArrayLike$3;
  var arraySpeciesCreate = arraySpeciesCreate$1;
  var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation

  var createMethod$1 = function createMethod(TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var IS_FILTER_REJECT = TYPE == 7;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that, specificCreate) {
      var O = toObject($this);
      var self = IndexedObject(O);
      var boundFunction = bind$7(callbackfn, that, 3);
      var length = lengthOfArrayLike(self);
      var index = 0;
      var create = specificCreate || arraySpeciesCreate;
      var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
      var value, result;

      for (; length > index; index++) {
        if (NO_HOLES || index in self) {
          value = self[index];
          result = boundFunction(value, index, O);

          if (TYPE) {
            if (IS_MAP) target[index] = result; // map
            else if (result) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return value;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                push.call(target, value);
              // filter
            } else switch (TYPE) {
              case 4:
                return false;
              // every

              case 7:
                push.call(target, value);
              // filterReject
            }
          }
        }
      }

      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };

  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod$1(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod$1(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod$1(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod$1(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod$1(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod$1(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod$1(6),
    // `Array.prototype.filterReject` method
    // https://github.com/tc39/proposal-array-filtering
    filterReject: createMethod$1(7)
  };

  var $$i = _export;
  var global$2 = global$c;
  var InternalMetadataModule = internalMetadata.exports;
  var fails = fails$b;
  var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
  var iterate$g = iterate$h;
  var anInstance$1 = anInstance$2;
  var isCallable$1 = isCallable$g;
  var isObject$3 = isObject$b;
  var setToStringTag = setToStringTag$3;
  var defineProperty$1 = objectDefineProperty.f;
  var forEach = arrayIteration.forEach;
  var DESCRIPTORS$2 = descriptors;
  var InternalStateModule$2 = internalState;
  var setInternalState$2 = InternalStateModule$2.set;
  var internalStateGetterFor$1 = InternalStateModule$2.getterFor;

  var collection$1 = function collection(CONSTRUCTOR_NAME, wrapper, common) {
    var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
    var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
    var ADDER = IS_MAP ? 'set' : 'add';
    var NativeConstructor = global$2[CONSTRUCTOR_NAME];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    var exported = {};
    var Constructor;

    if (!DESCRIPTORS$2 || !isCallable$1(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    }))) {
      // create collection constructor
      Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
      InternalMetadataModule.enable();
    } else {
      Constructor = wrapper(function (target, iterable) {
        setInternalState$2(anInstance$1(target, Constructor, CONSTRUCTOR_NAME), {
          type: CONSTRUCTOR_NAME,
          collection: new NativeConstructor()
        });
        if (iterable != undefined) iterate$g(iterable, target[ADDER], {
          that: target,
          AS_ENTRIES: IS_MAP
        });
      });
      var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
      forEach(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';

        if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {
          createNonEnumerableProperty$1(Constructor.prototype, KEY, function (a, b) {
            var collection = getInternalState(this).collection;
            if (!IS_ADDER && IS_WEAK && !isObject$3(a)) return KEY == 'get' ? undefined : false;
            var result = collection[KEY](a === 0 ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
        }
      });
      IS_WEAK || defineProperty$1(Constructor.prototype, 'size', {
        configurable: true,
        get: function get() {
          return getInternalState(this).collection.size;
        }
      });
    }

    setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);
    exported[CONSTRUCTOR_NAME] = Constructor;
    $$i({
      global: true,
      forced: true
    }, exported);
    if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
    return Constructor;
  };

  var redefine = redefine$3;

  var redefineAll$1 = function redefineAll(target, src, options) {
    for (var key in src) {
      if (options && options.unsafe && target[key]) target[key] = src[key];else redefine(target, key, src[key], options);
    }

    return target;
  };

  var getBuiltIn$7 = getBuiltIn$c;
  var definePropertyModule = objectDefineProperty;
  var wellKnownSymbol$2 = wellKnownSymbol$c;
  var DESCRIPTORS$1 = descriptors;
  var SPECIES$1 = wellKnownSymbol$2('species');

  var setSpecies$1 = function setSpecies(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn$7(CONSTRUCTOR_NAME);
    var defineProperty = definePropertyModule.f;

    if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES$1]) {
      defineProperty(Constructor, SPECIES$1, {
        configurable: true,
        get: function get() {
          return this;
        }
      });
    }
  };

  var defineProperty = objectDefineProperty.f;
  var create$1 = objectCreate;
  var redefineAll = redefineAll$1;
  var bind$6 = functionBindContext;
  var anInstance = anInstance$2;
  var iterate$f = iterate$h;
  var defineIterator$1 = defineIterator$3;
  var setSpecies = setSpecies$1;
  var DESCRIPTORS = descriptors;
  var fastKey = internalMetadata.exports.fastKey;
  var InternalStateModule$1 = internalState;
  var setInternalState$1 = InternalStateModule$1.set;
  var internalStateGetterFor = InternalStateModule$1.getterFor;
  var collectionStrong$1 = {
    getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        anInstance(that, C, CONSTRUCTOR_NAME);
        setInternalState$1(that, {
          type: CONSTRUCTOR_NAME,
          index: create$1(null),
          first: undefined,
          last: undefined,
          size: 0
        });
        if (!DESCRIPTORS) that.size = 0;
        if (iterable != undefined) iterate$f(iterable, that[ADDER], {
          that: that,
          AS_ENTRIES: IS_MAP
        });
      });
      var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

      var define = function define(that, key, value) {
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        var previous, index; // change existing entry

        if (entry) {
          entry.value = value; // create new entry
        } else {
          state.last = entry = {
            index: index = fastKey(key, true),
            key: key,
            value: value,
            previous: previous = state.last,
            next: undefined,
            removed: false
          };
          if (!state.first) state.first = entry;
          if (previous) previous.next = entry;
          if (DESCRIPTORS) state.size++;else that.size++; // add to index

          if (index !== 'F') state.index[index] = entry;
        }

        return that;
      };

      var getEntry = function getEntry(that, key) {
        var state = getInternalState(that); // fast case

        var index = fastKey(key);
        var entry;
        if (index !== 'F') return state.index[index]; // frozen object case

        for (entry = state.first; entry; entry = entry.next) {
          if (entry.key == key) return entry;
        }
      };

      redefineAll(C.prototype, {
        // `{ Map, Set }.prototype.clear()` methods
        // https://tc39.es/ecma262/#sec-map.prototype.clear
        // https://tc39.es/ecma262/#sec-set.prototype.clear
        clear: function clear() {
          var that = this;
          var state = getInternalState(that);
          var data = state.index;
          var entry = state.first;

          while (entry) {
            entry.removed = true;
            if (entry.previous) entry.previous = entry.previous.next = undefined;
            delete data[entry.index];
            entry = entry.next;
          }

          state.first = state.last = undefined;
          if (DESCRIPTORS) state.size = 0;else that.size = 0;
        },
        // `{ Map, Set }.prototype.delete(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.delete
        // https://tc39.es/ecma262/#sec-set.prototype.delete
        'delete': function _delete(key) {
          var that = this;
          var state = getInternalState(that);
          var entry = getEntry(that, key);

          if (entry) {
            var next = entry.next;
            var prev = entry.previous;
            delete state.index[entry.index];
            entry.removed = true;
            if (prev) prev.next = next;
            if (next) next.previous = prev;
            if (state.first == entry) state.first = next;
            if (state.last == entry) state.last = prev;
            if (DESCRIPTORS) state.size--;else that.size--;
          }

          return !!entry;
        },
        // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.foreach
        // https://tc39.es/ecma262/#sec-set.prototype.foreach
        forEach: function forEach(callbackfn
        /* , that = undefined */
        ) {
          var state = getInternalState(this);
          var boundFunction = bind$6(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
          var entry;

          while (entry = entry ? entry.next : state.first) {
            boundFunction(entry.value, entry.key, this); // revert to the last existing entry

            while (entry && entry.removed) {
              entry = entry.previous;
            }
          }
        },
        // `{ Map, Set}.prototype.has(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.has
        // https://tc39.es/ecma262/#sec-set.prototype.has
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      redefineAll(C.prototype, IS_MAP ? {
        // `Map.prototype.get(key)` method
        // https://tc39.es/ecma262/#sec-map.prototype.get
        get: function get(key) {
          var entry = getEntry(this, key);
          return entry && entry.value;
        },
        // `Map.prototype.set(key, value)` method
        // https://tc39.es/ecma262/#sec-map.prototype.set
        set: function set(key, value) {
          return define(this, key === 0 ? 0 : key, value);
        }
      } : {
        // `Set.prototype.add(value)` method
        // https://tc39.es/ecma262/#sec-set.prototype.add
        add: function add(value) {
          return define(this, value = value === 0 ? 0 : value, value);
        }
      });
      if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
        get: function get() {
          return getInternalState(this).size;
        }
      });
      return C;
    },
    setStrong: function setStrong(C, CONSTRUCTOR_NAME, IS_MAP) {
      var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
      var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
      var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.entries
      // https://tc39.es/ecma262/#sec-map.prototype.keys
      // https://tc39.es/ecma262/#sec-map.prototype.values
      // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
      // https://tc39.es/ecma262/#sec-set.prototype.entries
      // https://tc39.es/ecma262/#sec-set.prototype.keys
      // https://tc39.es/ecma262/#sec-set.prototype.values
      // https://tc39.es/ecma262/#sec-set.prototype-@@iterator

      defineIterator$1(C, CONSTRUCTOR_NAME, function (iterated, kind) {
        setInternalState$1(this, {
          type: ITERATOR_NAME,
          target: iterated,
          state: getInternalCollectionState(iterated),
          kind: kind,
          last: undefined
        });
      }, function () {
        var state = getInternalIteratorState(this);
        var kind = state.kind;
        var entry = state.last; // revert to the last existing entry

        while (entry && entry.removed) {
          entry = entry.previous;
        } // get next entry


        if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
          // or finish the iteration
          state.target = undefined;
          return {
            value: undefined,
            done: true
          };
        } // return step by kind


        if (kind == 'keys') return {
          value: entry.key,
          done: false
        };
        if (kind == 'values') return {
          value: entry.value,
          done: false
        };
        return {
          value: [entry.key, entry.value],
          done: false
        };
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // `{ Map, Set }.prototype[@@species]` accessors
      // https://tc39.es/ecma262/#sec-get-map-@@species
      // https://tc39.es/ecma262/#sec-get-set-@@species

      setSpecies(CONSTRUCTOR_NAME);
    }
  };

  var collection = collection$1;
  var collectionStrong = collectionStrong$1; // `Set` constructor
  // https://tc39.es/ecma262/#sec-set-objects

  collection('Set', function (init) {
    return function Set() {
      return init(this, arguments.length ? arguments[0] : undefined);
    };
  }, collectionStrong);

  var classof$1 = classof$6;

  var toString$2 = function toString(argument) {
    if (classof$1(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
    return String(argument);
  };

  var toIntegerOrInfinity = toIntegerOrInfinity$3;
  var toString$1 = toString$2;
  var requireObjectCoercible = requireObjectCoercible$3;

  var createMethod = function createMethod(CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = toString$1(requireObjectCoercible($this));
      var position = toIntegerOrInfinity(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = S.charCodeAt(position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
  };

  var charAt = stringMultibyte.charAt;
  var toString = toString$2;
  var InternalStateModule = internalState;
  var defineIterator = defineIterator$3;
  var STRING_ITERATOR = 'String Iterator';
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-string.prototype-@@iterator

  defineIterator(String, 'String', function (iterated) {
    setInternalState(this, {
      type: STRING_ITERATOR,
      string: toString(iterated),
      index: 0
    }); // `%StringIteratorPrototype%.next` method
    // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
  }, function next() {
    var state = getInternalState(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return {
      value: undefined,
      done: true
    };
    point = charAt(string, index);
    state.index += point.length;
    return {
      value: point,
      done: false
    };
  });

  var path = path$4;
  var set$2 = path.Set;

  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods

  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  var DOMIterables = domIterables;
  var global$1 = global$c;
  var classof = classof$6;
  var createNonEnumerableProperty = createNonEnumerableProperty$6;
  var Iterators = iterators;
  var wellKnownSymbol$1 = wellKnownSymbol$c;
  var TO_STRING_TAG = wellKnownSymbol$1('toStringTag');

  for (var COLLECTION_NAME in DOMIterables) {
    var Collection = global$1[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;

    if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }

    Iterators[COLLECTION_NAME] = Iterators.Array;
  }

  var parent$1 = set$2;
  var set$1 = parent$1;

  var isConstructor = isConstructor$2;
  var tryToString = tryToString$2; // `Assert: IsConstructor(argument) is true`

  var aConstructor$2 = function aConstructor(argument) {
    if (isConstructor(argument)) return argument;
    throw TypeError(tryToString(argument) + ' is not a constructor');
  };

  var aCallable$c = aCallable$g;
  var aConstructor$1 = aConstructor$2;
  var bind$5 = functionBindContext;
  var iterate$e = iterate$h;

  var collectionFrom = function from(source
  /* , mapFn, thisArg */
  ) {
    var length = arguments.length;
    var mapFn = length > 1 ? arguments[1] : undefined;
    var mapping, array, n, boundFunction;
    aConstructor$1(this);
    mapping = mapFn !== undefined;
    if (mapping) aCallable$c(mapFn);
    if (source == undefined) return new this();
    array = [];

    if (mapping) {
      n = 0;
      boundFunction = bind$5(mapFn, length > 2 ? arguments[2] : undefined, 2);
      iterate$e(source, function (nextItem) {
        array.push(boundFunction(nextItem, n++));
      });
    } else {
      iterate$e(source, array.push, {
        that: array
      });
    }

    return new this(array);
  };

  var $$h = _export;
  var from = collectionFrom; // `Set.from` method
  // https://tc39.github.io/proposal-setmap-offrom/#sec-set.from

  $$h({
    target: 'Set',
    stat: true
  }, {
    from: from
  });

  var collectionOf = function of() {
    var length = arguments.length;
    var A = new Array(length);

    while (length--) {
      A[length] = arguments[length];
    }

    return new this(A);
  };

  var $$g = _export;
  var of = collectionOf; // `Set.of` method
  // https://tc39.github.io/proposal-setmap-offrom/#sec-set.of

  $$g({
    target: 'Set',
    stat: true
  }, {
    of: of
  });

  var aCallable$b = aCallable$g;
  var anObject$g = anObject$o; // https://github.com/tc39/collection-methods

  var collectionAddAll$1 = function collectionAddAll() {
    var set = anObject$g(this);
    var adder = aCallable$b(set.add);

    for (var k = 0, len = arguments.length; k < len; k++) {
      adder.call(set, arguments[k]);
    }

    return set;
  };

  var $$f = _export;
  var IS_PURE$f = isPure;
  var collectionAddAll = collectionAddAll$1; // `Set.prototype.addAll` method
  // https://github.com/tc39/proposal-collection-methods

  $$f({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$f
  }, {
    addAll: function addAll() {
      return collectionAddAll.apply(this, arguments);
    }
  });

  var aCallable$a = aCallable$g;
  var anObject$f = anObject$o; // https://github.com/tc39/collection-methods

  var collectionDeleteAll$1 = function collectionDeleteAll() {
    var collection = anObject$f(this);
    var remover = aCallable$a(collection['delete']);
    var allDeleted = true;
    var wasDeleted;

    for (var k = 0, len = arguments.length; k < len; k++) {
      wasDeleted = remover.call(collection, arguments[k]);
      allDeleted = allDeleted && wasDeleted;
    }

    return !!allDeleted;
  };

  var $$e = _export;
  var IS_PURE$e = isPure;
  var collectionDeleteAll = collectionDeleteAll$1; // `Set.prototype.deleteAll` method
  // https://github.com/tc39/proposal-collection-methods

  $$e({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$e
  }, {
    deleteAll: function deleteAll() {
      return collectionDeleteAll.apply(this, arguments);
    }
  });

  var getIterator$1 = getIterator$3;
  var getSetIterator$7 = getIterator$1;

  var $$d = _export;
  var IS_PURE$d = isPure;
  var anObject$e = anObject$o;
  var bind$4 = functionBindContext;
  var getSetIterator$6 = getSetIterator$7;
  var iterate$d = iterate$h; // `Set.prototype.every` method
  // https://github.com/tc39/proposal-collection-methods

  $$d({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$d
  }, {
    every: function every(callbackfn
    /* , thisArg */
    ) {
      var set = anObject$e(this);
      var iterator = getSetIterator$6(set);
      var boundFunction = bind$4(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
      return !iterate$d(iterator, function (value, stop) {
        if (!boundFunction(value, value, set)) return stop();
      }, {
        IS_ITERATOR: true,
        INTERRUPTED: true
      }).stopped;
    }
  });

  var anObject$d = anObject$o;
  var aConstructor = aConstructor$2;
  var wellKnownSymbol = wellKnownSymbol$c;
  var SPECIES = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-speciesconstructor

  var speciesConstructor$6 = function speciesConstructor(O, defaultConstructor) {
    var C = anObject$d(O).constructor;
    var S;
    return C === undefined || (S = anObject$d(C)[SPECIES]) == undefined ? defaultConstructor : aConstructor(S);
  };

  var $$c = _export;
  var IS_PURE$c = isPure;
  var getBuiltIn$6 = getBuiltIn$c;
  var aCallable$9 = aCallable$g;
  var anObject$c = anObject$o;
  var speciesConstructor$5 = speciesConstructor$6;
  var iterate$c = iterate$h; // `Set.prototype.difference` method
  // https://github.com/tc39/proposal-set-methods

  $$c({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$c
  }, {
    difference: function difference(iterable) {
      var set = anObject$c(this);
      var newSet = new (speciesConstructor$5(set, getBuiltIn$6('Set')))(set);
      var remover = aCallable$9(newSet['delete']);
      iterate$c(iterable, function (value) {
        remover.call(newSet, value);
      });
      return newSet;
    }
  });

  var $$b = _export;
  var IS_PURE$b = isPure;
  var getBuiltIn$5 = getBuiltIn$c;
  var aCallable$8 = aCallable$g;
  var anObject$b = anObject$o;
  var bind$3 = functionBindContext;
  var speciesConstructor$4 = speciesConstructor$6;
  var getSetIterator$5 = getSetIterator$7;
  var iterate$b = iterate$h; // `Set.prototype.filter` method
  // https://github.com/tc39/proposal-collection-methods

  $$b({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$b
  }, {
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      var set = anObject$b(this);
      var iterator = getSetIterator$5(set);
      var boundFunction = bind$3(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
      var newSet = new (speciesConstructor$4(set, getBuiltIn$5('Set')))();
      var adder = aCallable$8(newSet.add);
      iterate$b(iterator, function (value) {
        if (boundFunction(value, value, set)) adder.call(newSet, value);
      }, {
        IS_ITERATOR: true
      });
      return newSet;
    }
  });

  var $$a = _export;
  var IS_PURE$a = isPure;
  var anObject$a = anObject$o;
  var bind$2 = functionBindContext;
  var getSetIterator$4 = getSetIterator$7;
  var iterate$a = iterate$h; // `Set.prototype.find` method
  // https://github.com/tc39/proposal-collection-methods

  $$a({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$a
  }, {
    find: function find(callbackfn
    /* , thisArg */
    ) {
      var set = anObject$a(this);
      var iterator = getSetIterator$4(set);
      var boundFunction = bind$2(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
      return iterate$a(iterator, function (value, stop) {
        if (boundFunction(value, value, set)) return stop(value);
      }, {
        IS_ITERATOR: true,
        INTERRUPTED: true
      }).result;
    }
  });

  var $$9 = _export;
  var IS_PURE$9 = isPure;
  var getBuiltIn$4 = getBuiltIn$c;
  var aCallable$7 = aCallable$g;
  var anObject$9 = anObject$o;
  var speciesConstructor$3 = speciesConstructor$6;
  var iterate$9 = iterate$h; // `Set.prototype.intersection` method
  // https://github.com/tc39/proposal-set-methods

  $$9({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$9
  }, {
    intersection: function intersection(iterable) {
      var set = anObject$9(this);
      var newSet = new (speciesConstructor$3(set, getBuiltIn$4('Set')))();
      var hasCheck = aCallable$7(set.has);
      var adder = aCallable$7(newSet.add);
      iterate$9(iterable, function (value) {
        if (hasCheck.call(set, value)) adder.call(newSet, value);
      });
      return newSet;
    }
  });

  var $$8 = _export;
  var IS_PURE$8 = isPure;
  var aCallable$6 = aCallable$g;
  var anObject$8 = anObject$o;
  var iterate$8 = iterate$h; // `Set.prototype.isDisjointFrom` method
  // https://tc39.github.io/proposal-set-methods/#Set.prototype.isDisjointFrom

  $$8({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$8
  }, {
    isDisjointFrom: function isDisjointFrom(iterable) {
      var set = anObject$8(this);
      var hasCheck = aCallable$6(set.has);
      return !iterate$8(iterable, function (value, stop) {
        if (hasCheck.call(set, value) === true) return stop();
      }, {
        INTERRUPTED: true
      }).stopped;
    }
  });

  var $$7 = _export;
  var IS_PURE$7 = isPure;
  var getBuiltIn$3 = getBuiltIn$c;
  var aCallable$5 = aCallable$g;
  var isCallable = isCallable$g;
  var anObject$7 = anObject$o;
  var getIterator = getIterator$3;
  var iterate$7 = iterate$h; // `Set.prototype.isSubsetOf` method
  // https://tc39.github.io/proposal-set-methods/#Set.prototype.isSubsetOf

  $$7({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$7
  }, {
    isSubsetOf: function isSubsetOf(iterable) {
      var iterator = getIterator(this);
      var otherSet = anObject$7(iterable);
      var hasCheck = otherSet.has;

      if (!isCallable(hasCheck)) {
        otherSet = new (getBuiltIn$3('Set'))(iterable);
        hasCheck = aCallable$5(otherSet.has);
      }

      return !iterate$7(iterator, function (value, stop) {
        if (hasCheck.call(otherSet, value) === false) return stop();
      }, {
        IS_ITERATOR: true,
        INTERRUPTED: true
      }).stopped;
    }
  });

  var $$6 = _export;
  var IS_PURE$6 = isPure;
  var aCallable$4 = aCallable$g;
  var anObject$6 = anObject$o;
  var iterate$6 = iterate$h; // `Set.prototype.isSupersetOf` method
  // https://tc39.github.io/proposal-set-methods/#Set.prototype.isSupersetOf

  $$6({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$6
  }, {
    isSupersetOf: function isSupersetOf(iterable) {
      var set = anObject$6(this);
      var hasCheck = aCallable$4(set.has);
      return !iterate$6(iterable, function (value, stop) {
        if (hasCheck.call(set, value) === false) return stop();
      }, {
        INTERRUPTED: true
      }).stopped;
    }
  });

  var $$5 = _export;
  var IS_PURE$5 = isPure;
  var anObject$5 = anObject$o;
  var getSetIterator$3 = getSetIterator$7;
  var iterate$5 = iterate$h; // `Set.prototype.join` method
  // https://github.com/tc39/proposal-collection-methods

  $$5({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$5
  }, {
    join: function join(separator) {
      var set = anObject$5(this);
      var iterator = getSetIterator$3(set);
      var sep = separator === undefined ? ',' : String(separator);
      var result = [];
      iterate$5(iterator, result.push, {
        that: result,
        IS_ITERATOR: true
      });
      return result.join(sep);
    }
  });

  var $$4 = _export;
  var IS_PURE$4 = isPure;
  var getBuiltIn$2 = getBuiltIn$c;
  var aCallable$3 = aCallable$g;
  var anObject$4 = anObject$o;
  var bind$1 = functionBindContext;
  var speciesConstructor$2 = speciesConstructor$6;
  var getSetIterator$2 = getSetIterator$7;
  var iterate$4 = iterate$h; // `Set.prototype.map` method
  // https://github.com/tc39/proposal-collection-methods

  $$4({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$4
  }, {
    map: function map(callbackfn
    /* , thisArg */
    ) {
      var set = anObject$4(this);
      var iterator = getSetIterator$2(set);
      var boundFunction = bind$1(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
      var newSet = new (speciesConstructor$2(set, getBuiltIn$2('Set')))();
      var adder = aCallable$3(newSet.add);
      iterate$4(iterator, function (value) {
        adder.call(newSet, boundFunction(value, value, set));
      }, {
        IS_ITERATOR: true
      });
      return newSet;
    }
  });

  var $$3 = _export;
  var IS_PURE$3 = isPure;
  var aCallable$2 = aCallable$g;
  var anObject$3 = anObject$o;
  var getSetIterator$1 = getSetIterator$7;
  var iterate$3 = iterate$h; // `Set.prototype.reduce` method
  // https://github.com/tc39/proposal-collection-methods

  $$3({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$3
  }, {
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      var set = anObject$3(this);
      var iterator = getSetIterator$1(set);
      var noInitial = arguments.length < 2;
      var accumulator = noInitial ? undefined : arguments[1];
      aCallable$2(callbackfn);
      iterate$3(iterator, function (value) {
        if (noInitial) {
          noInitial = false;
          accumulator = value;
        } else {
          accumulator = callbackfn(accumulator, value, value, set);
        }
      }, {
        IS_ITERATOR: true
      });
      if (noInitial) throw TypeError('Reduce of empty set with no initial value');
      return accumulator;
    }
  });

  var $$2 = _export;
  var IS_PURE$2 = isPure;
  var anObject$2 = anObject$o;
  var bind = functionBindContext;
  var getSetIterator = getSetIterator$7;
  var iterate$2 = iterate$h; // `Set.prototype.some` method
  // https://github.com/tc39/proposal-collection-methods

  $$2({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$2
  }, {
    some: function some(callbackfn
    /* , thisArg */
    ) {
      var set = anObject$2(this);
      var iterator = getSetIterator(set);
      var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
      return iterate$2(iterator, function (value, stop) {
        if (boundFunction(value, value, set)) return stop();
      }, {
        IS_ITERATOR: true,
        INTERRUPTED: true
      }).stopped;
    }
  });

  var $$1 = _export;
  var IS_PURE$1 = isPure;
  var getBuiltIn$1 = getBuiltIn$c;
  var aCallable$1 = aCallable$g;
  var anObject$1 = anObject$o;
  var speciesConstructor$1 = speciesConstructor$6;
  var iterate$1 = iterate$h; // `Set.prototype.symmetricDifference` method
  // https://github.com/tc39/proposal-set-methods

  $$1({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE$1
  }, {
    symmetricDifference: function symmetricDifference(iterable) {
      var set = anObject$1(this);
      var newSet = new (speciesConstructor$1(set, getBuiltIn$1('Set')))(set);
      var remover = aCallable$1(newSet['delete']);
      var adder = aCallable$1(newSet.add);
      iterate$1(iterable, function (value) {
        remover.call(newSet, value) || adder.call(newSet, value);
      });
      return newSet;
    }
  });

  var $ = _export;
  var IS_PURE = isPure;
  var getBuiltIn = getBuiltIn$c;
  var aCallable = aCallable$g;
  var anObject = anObject$o;
  var speciesConstructor = speciesConstructor$6;
  var iterate = iterate$h; // `Set.prototype.union` method
  // https://github.com/tc39/proposal-set-methods

  $({
    target: 'Set',
    proto: true,
    real: true,
    forced: IS_PURE
  }, {
    union: function union(iterable) {
      var set = anObject(this);
      var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
      iterate(iterable, aCallable(newSet.add), {
        that: newSet
      });
      return newSet;
    }
  });

  var parent = set$1;
  var set = parent;

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function t(t, n) {
    var e = "function" == typeof Symbol && t[Symbol.iterator];
    if (!e) return t;
    var r,
        o,
        i = e.call(t),
        a = [];

    try {
      for (; (void 0 === n || n-- > 0) && !(r = i.next()).done;) {
        a.push(r.value);
      }
    } catch (t) {
      o = {
        error: t
      };
    } finally {
      try {
        r && !r.done && (e = i.return) && e.call(i);
      } finally {
        if (o) throw o.error;
      }
    }

    return a;
  }

  var n;
  !function (t) {
    t[t.NotStarted = 0] = "NotStarted", t[t.Running = 1] = "Running", t[t.Stopped = 2] = "Stopped";
  }(n || (n = {}));
  var e = {
    type: "xstate.init"
  };

  function r(t) {
    return void 0 === t ? [] : [].concat(t);
  }

  function o(t) {
    return {
      type: "xstate.assign",
      assignment: t
    };
  }

  function i(t, n) {
    return "string" == typeof (t = "string" == typeof t && n && n[t] ? n[t] : t) ? {
      type: t
    } : "function" == typeof t ? {
      type: t.name,
      exec: t
    } : t;
  }

  function a(t) {
    return function (n) {
      return t === n;
    };
  }

  function u(t) {
    return "string" == typeof t ? {
      type: t
    } : t;
  }

  function c(t, n) {
    return {
      value: t,
      context: n,
      actions: [],
      changed: !1,
      matches: a(t)
    };
  }

  function f(t, n, e) {
    var r = n,
        o = !1;
    return [t.filter(function (t) {
      if ("xstate.assign" === t.type) {
        o = !0;
        var n = $inject_Object_assign({}, r);
        return "function" == typeof t.assignment ? n = t.assignment(r, e) : Object.keys(t.assignment).forEach(function (o) {
          n[o] = "function" == typeof t.assignment[o] ? t.assignment[o](r, e) : t.assignment[o];
        }), r = n, !1;
      }

      return !0;
    }), r, o];
  }

  function s(n, o) {
    void 0 === o && (o = {});
    var s = t(f(r(n.states[n.initial].entry).map(function (t) {
      return i(t, o.actions);
    }), n.context, e), 2),
        l = s[0],
        v = s[1],
        y = {
      config: n,
      _options: o,
      initialState: {
        value: n.initial,
        actions: l,
        context: v,
        matches: a(n.initial)
      },
      transition: function transition(e, o) {
        var s,
            l,
            v = "string" == typeof e ? {
          value: e,
          context: n.context
        } : e,
            p = v.value,
            g = v.context,
            d = u(o),
            x = n.states[p];

        if (x.on) {
          var m = r(x.on[d.type]);

          try {
            for (var h = function (t) {
              var n = "function" == typeof Symbol && Symbol.iterator,
                  e = n && t[n],
                  r = 0;
              if (e) return e.call(t);
              if (t && "number" == typeof t.length) return {
                next: function next() {
                  return t && r >= t.length && (t = void 0), {
                    value: t && t[r++],
                    done: !t
                  };
                }
              };
              throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }(m), b = h.next(); !b.done; b = h.next()) {
              var S = b.value;
              if (void 0 === S) return c(p, g);

              var w = "string" == typeof S ? {
                target: S
              } : S,
                  j = w.target,
                  E = w.actions,
                  R = void 0 === E ? [] : E,
                  N = w.cond,
                  O = void 0 === N ? function () {
                return !0;
              } : N,
                  _ = void 0 === j,
                  k = null != j ? j : p,
                  T = n.states[k];

              if (O(g, d)) {
                var q = t(f((_ ? r(R) : [].concat(x.exit, R, T.entry).filter(function (t) {
                  return t;
                })).map(function (t) {
                  return i(t, y._options.actions);
                }), g, d), 3),
                    z = q[0],
                    A = q[1],
                    B = q[2],
                    C = null != j ? j : p;
                return {
                  value: C,
                  context: A,
                  actions: z,
                  changed: j !== p || z.length > 0 || B,
                  matches: a(C)
                };
              }
            }
          } catch (t) {
            s = {
              error: t
            };
          } finally {
            try {
              b && !b.done && (l = h.return) && l.call(h);
            } finally {
              if (s) throw s.error;
            }
          }
        }

        return c(p, g);
      }
    };
    return y;
  }

  var l = function l(t, n) {
    return t.actions.forEach(function (e) {
      var r = e.exec;
      return r && r(t.context, n);
    });
  };

  function v(t) {
    var r = t.initialState,
        o = n.NotStarted,
        i = new set(),
        c = {
      _machine: t,
      send: function send(e) {
        o === n.Running && (r = t.transition(r, e), l(r, u(e)), i.forEach(function (t) {
          return t(r);
        }));
      },
      subscribe: function subscribe(t) {
        return i.add(t), t(r), {
          unsubscribe: function unsubscribe() {
            return i.delete(t);
          }
        };
      },
      start: function start(i) {
        if (i) {
          var u = "object" == _typeof(i) ? i : {
            context: t.config.context,
            value: i
          };
          r = {
            value: u.value,
            actions: [],
            context: u.context,
            matches: a(u.value)
          };
        }

        return o = n.Running, l(r, e), c;
      },
      stop: function stop() {
        return o = n.Stopped, i.clear(), c;
      },

      get state() {
        return r;
      },

      get status() {
        return o;
      }

    };
    return c;
  }

  function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * @hidden
   */

  var INPUT = {
    INPUT: {
      actions: "input"
    }
  };
  /**
   * @hidden
   */

  var CLOSE = {
    CLOSE: "closed"
  };
  /**
   * @hidden
   */

  var SUGGEST = {
    SUGGEST: {
      target: "suggesting",
      actions: ["updateSuggestions"]
    }
  };
  /**
   * @hidden
   */

  var NOTIFY = {
    NOTIFY: {
      target: "notifying",
      actions: ["updateMessage"]
    }
  };
  /**
   * Creates a finite state machine that drives Address Finder UI
   */

  var create = function create(_ref) {
    var view = _ref.view;
    var machine = s({
      initial: "closed",
      context: {
        suggestions: [],
        message: view.options.msgInitial,
        current: -1
      },
      states: {
        closed: {
          entry: ["close"],
          exit: ["open"],
          on: {
            AWAKE: [{
              target: "suggesting",
              cond: function cond(c) {
                return c.suggestions.length > 0;
              }
            }, {
              target: "notifying"
            }]
          }
        },
        notifying: {
          entry: ["renderNotice"],
          exit: ["clearAnnouncement"],
          on: _objectSpread$3(_objectSpread$3(_objectSpread$3(_objectSpread$3({}, CLOSE), SUGGEST), NOTIFY), INPUT)
        },
        suggesting: {
          entry: ["renderSuggestions", "gotoCurrent", "expand"],
          exit: ["resetCurrent", "gotoCurrent", "contract"],
          on: _objectSpread$3(_objectSpread$3(_objectSpread$3(_objectSpread$3(_objectSpread$3({}, CLOSE), SUGGEST), NOTIFY), INPUT), {}, {
            NEXT: {
              actions: ["next", "gotoCurrent"]
            },
            PREVIOUS: {
              actions: ["previous", "gotoCurrent"]
            },
            RESET: {
              actions: ["resetCurrent", "gotoCurrent"]
            },
            SELECT: {
              target: "closed",
              actions: ["select"]
            }
          })
        }
      }
    }, {
      actions: {
        /**
         * Updates current li in list to active descendant
         */
        gotoCurrent: function gotoCurrent(c) {
          var lis = view.list.children;
          view.input.setAttribute("aria-activedescendant", "");

          for (var i = 0; i < lis.length; i += 1) {
            if (i === c.current) {
              view.input.setAttribute("aria-activedescendant", lis[i].id);
              lis[i].setAttribute("aria-selected", "true");
              view.goto(i);
            } else {
              lis[i].setAttribute("aria-selected", "false");
            }
          }
        },

        /**
         * Unhighlights a suggestion
         */
        resetCurrent: o({
          current: -1
        }),

        /**
         * Triggers onInput callback
         */
        input: function input(_, e) {
          if (e.type !== "INPUT") return;
          view.options.onInput.call(view, e.event);
        },

        /**
         * Clears ARIA announcement fields
         */
        clearAnnouncement: function clearAnnouncement() {
          return view.announce("");
        },

        /**
         * Renders suggestion within list
         */
        renderSuggestions: function renderSuggestions(c, e) {
          if (e.type !== "SUGGEST") return;
          view.list.innerHTML = "";
          var id = view.list.id;
          var s = c.suggestions;
          s.forEach(function (_ref2, i) {
            var suggestion = _ref2.suggestion;
            var li = view.options.document.createElement("li");
            li.textContent = suggestion;
            li.setAttribute("aria-selected", "false");
            li.setAttribute("tabindex", "-1");
            li.setAttribute("aria-posinset", "".concat(i + 1));
            li.setAttribute("aria-setsize", s.length.toString());
            li.setAttribute("role", "option");
            setStyle(li, view.options.liStyle);
            li.id = "".concat(id, "_").concat(i);
            view.list.appendChild(li);
          });
          view.announce("".concat(s.length, " addresses available"));
        },

        /**
         * Update context.suggestions
         */
        updateSuggestions: o({
          suggestions: function suggestions(c, e) {
            if (e.type !== "SUGGEST") return c.suggestions;
            return e.suggestions;
          },
          current: function current() {
            return -1;
          }
        }),

        /**
         * Hides list and runs callback
         */
        close: function close(_, e) {
          var reason = "blur";
          if (e.type === "CLOSE") reason = e.reason;
          hide(view.list);
          if (e.type === "CLOSE" && e.reason === "esc") update$1(view.input, "");
          view.options.onClose.call(view, reason);
        },

        /**
         * Makes list visible and run callback
         */
        open: function open() {
          show(view.list);
          view.options.onOpen.call(view);
        },

        /**
         * Marks aria component as expanded
         */
        expand: function expand() {
          view.ariaAnchor().setAttribute("aria-expanded", "true");
        },

        /**
         * Marks aria component as closed
         */
        contract: function contract() {
          view.ariaAnchor().setAttribute("aria-expanded", "false");
        },

        /**
         * Assigns context.message
         */
        updateMessage: o({
          message: function message(c, e) {
            if (e.type !== "NOTIFY") return c.message;
            return e.message;
          }
        }),

        /**
         * Renders message container and current message
         */
        renderNotice: function renderNotice(c) {
          view.list.innerHTML = "";
          view.input.setAttribute("aria-activedescendant", "");
          view.message.textContent = c.message;
          view.announce(c.message);
          view.list.appendChild(view.message);
        },

        /**
         * Selects next element in list. Wraps to top if at bottom
         */
        next: o({
          current: function current(c) {
            return c.current + 1 > view.list.children.length - 1 ? 0 // Wrap to first elem
            : c.current + 1;
          }
        }),

        /**
         * Selects previous element in list. Wraps to bottom if at top
         */
        previous: o({
          current: function current(c) {
            return c.current - 1 < 0 ? view.list.children.length - 1 // Wrap to last elem
            : c.current - 1;
          }
        }),

        /**
         * Triggers select on current suggestion or clicked element
         */
        select: function select(_, e) {
          if (e.type !== "SELECT") return;
          view.options.onSelect.call(view, e.suggestion);
          view.announce("The address ".concat(e.suggestion.suggestion, " has been applied to this form"));
        }
      }
    });
    return v(machine);
  };

  function isObject$2(value) {
    var type = _typeof(value);

    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject$2;

  var freeGlobal$1 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal$1;

  var freeGlobal = _freeGlobal;
  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root$2 = freeGlobal || freeSelf || Function('return this')();
  var _root = root$2;

  var root$1 = _root;
  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */

  var now$1 = function now() {
    return root$1.Date.now();
  };

  var now_1 = now$1;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;
  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */

  function trimmedEndIndex$1(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}

    return index;
  }

  var _trimmedEndIndex = trimmedEndIndex$1;

  var trimmedEndIndex = _trimmedEndIndex;
  /** Used to match leading whitespace. */

  var reTrimStart = /^\s+/;
  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */

  function baseTrim$1(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
  }

  var _baseTrim = baseTrim$1;

  var root = _root;
  /** Built-in value references. */

  var _Symbol2 = root.Symbol;
  var _Symbol$2 = _Symbol2;

  var _Symbol$1 = _Symbol$2;
  /** Used for built-in method references. */

  var objectProto$1 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto$1.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString$1 = objectProto$1.toString;
  /** Built-in value references. */

  var symToStringTag$1 = _Symbol$1 ? _Symbol$1.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag$1(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag$1;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString$1(value) {
    return nativeObjectToString.call(value);
  }

  var _objectToString = objectToString$1;

  var _Symbol = _Symbol$2,
      getRawTag = _getRawTag,
      objectToString = _objectToString;
  /** `Object#toString` result references. */

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag$1(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  var _baseGetTag = baseGetTag$1;

  function isObjectLike$1(value) {
    return value != null && _typeof(value) == 'object';
  }

  var isObjectLike_1 = isObjectLike$1;

  var baseGetTag = _baseGetTag,
      isObjectLike = isObjectLike_1;
  /** `Object#toString` result references. */

  var symbolTag = '[object Symbol]';
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol$1(value) {
    return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }

  var isSymbol_1 = isSymbol$1;

  var baseTrim = _baseTrim,
      isObject$1 = isObject_1,
      isSymbol = isSymbol_1;
  /** Used as references for various `Number` constants. */

  var NAN = 0 / 0;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */

  function toNumber$1(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol(value)) {
      return NAN;
    }

    if (isObject$1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject$1(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var toNumber_1 = toNumber$1;

  var isObject = isObject_1,
      now = now_1,
      toNumber = toNumber_1;
  /** Error message constants. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax = Math.max,
      nativeMin = Math.min;
  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */

  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    wait = toNumber(wait) || 0;

    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;
      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time; // Start the timer for the trailing edge.

      timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.

      return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }

    function timerExpired() {
      var time = now();

      if (shouldInvoke(time)) {
        return trailingEdge(time);
      } // Restart the timer.


      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.

      if (trailing && lastArgs) {
        return invokeFunc(time);
      }

      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }

      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }

        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }

      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }

      return result;
    }

    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  var debounce_1 = debounce;

  /**
   * @hidden
   */

  var reset = "border:0px;padding:0px;";
  /**
   * @hidden
   */

  var hidden = "clip:rect(0px,0px,0px,0px);height:1px;margin-bottom:-1px;margin-right:-1px;overflow:hidden;position:absolute;white-space:nowrap;width:1px";
  /**
   * @hidden
   */

  var update = function update(e, id) {
    e.id = id;
    e.setAttribute("role", "status");
    e.setAttribute("aria-live", "polite");
    e.setAttribute("aria-atomic", "true");
    return e;
  };
  /**
   * Generates a screen reader compatible live area for announcements
   *
   * @hidden
   */


  var announcer = function announcer(_ref) {
    var document = _ref.document,
        idA = _ref.idA,
        idB = _ref.idB;
    var container = document.createElement("div");
    container.setAttribute("style", reset + hidden);
    var a = update(document.createElement("div"), idA);
    var b = update(document.createElement("div"), idB);
    container.appendChild(a);
    container.appendChild(b);
    var A = true;
    var announce = debounce_1(function (message) {
      var announcer = A ? a : b;
      var backup = A ? b : a;
      A = !A;
      announcer.textContent = message;
      backup.textContent = "";
    }, 1500, {});
    return {
      container: container,
      announce: announce
    };
  };

  /**
   * # View
   *
   * Represents the user interface which binds to the DOM.
   *
   * The View class is designed to be consumed by an
   * `Autocomplete.Controller` instance and should not be accessed directly
   * unless absolutely necessary.
   *
   * The main function of the View is to:
   * - Present suggestions supplied by the controller
   * - Provide callbacks to the controller for various user interactions
   * - Provide methods to manipulate the user interface if required
   */

  var View = /*#__PURE__*/function () {
    /**
     * Creates an View instance
     */
    function View(options) {
      _classCallCheck(this, View);

      this.options = options;
      this.ids = idGen("idpcaf");
      var inputField = options.inputField; // Configure container

      this.container = this.options.document.createElement("div");
      this.container.className = this.options.containerClass;
      this.container.id = this.ids();
      this.container.setAttribute("aria-haspopup", "listbox"); // Create message element

      this.message = this.options.document.createElement("li");
      this.message.textContent = this.options.msgInitial;
      this.message.className = "idpc_error"; // Configure UL

      this.list = this.options.document.createElement("ul");
      this.list.className = this.options.listClass;
      this.list.id = this.ids();
      this.list.setAttribute("aria-label", this.options.msgList);
      this.list.setAttribute("role", "listbox");
      hide(this.list); //configure unhide

      this.unhideEvent = this.unhideFields.bind(this);
      this.unhide = this.createUnhide(); // Configure input

      if (isString(inputField)) {
        this.input = this.options.scope.querySelector(inputField);
      } else {
        this.input = inputField;
      }

      this.input.setAttribute("autocomplete", this.options.autocomplete);
      this.input.setAttribute("aria-autocomplete", "list");
      this.input.setAttribute("aria-controls", this.list.id);
      this.input.setAttribute("aria-autocomplete", "list");
      this.input.setAttribute("aria-activedescendant", "");
      this.input.setAttribute("autocorrect", "off");
      this.input.setAttribute("autocapitalize", "off");
      this.input.setAttribute("spellcheck", "false");
      if (!this.input.id) this.input.id = this.ids(); // Apply additional accessibility improvments

      this.ariaAnchor().setAttribute("role", "combobox");
      this.ariaAnchor().setAttribute("aria-expanded", "false");
      this.ariaAnchor().setAttribute("aria-owns", this.list.id);
      this.inputListener = _onInput(this);
      this.blurListener = _onBlur(this);
      this.focusListener = _onFocus(this);
      this.keydownListener = _onKeyDown(this);
      this.mousedownListener = _onMousedown(this);

      var _announcer = announcer({
        idA: this.ids(),
        idB: this.ids(),
        document: this.options.document
      }),
          container = _announcer.container,
          announce = _announcer.announce;

      this.announce = announce;
      this.alerts = container;
      this.inputStyle = setStyle(this.input, this.options.inputStyle);
      setStyle(this.container, this.options.containerStyle);
      setStyle(this.list, this.options.listStyle);
      this.fsm = create({
        view: this
      });
    }
    /**
     * Adds View to DOM
     * - Wraps input with container
     * - Appends suggestion list to container
     * - Enables listeners
     * - Starts FSM
     */


    _createClass(View, [{
      key: "attach",
      value: function attach() {
        if (this.fsm.status === n.Running) return this;
        this.input.addEventListener("input", this.inputListener);
        this.input.addEventListener("blur", this.blurListener);
        this.input.addEventListener("focus", this.focusListener);
        this.input.addEventListener("keydown", this.keydownListener);
        this.list.addEventListener("mousedown", this.mousedownListener);
        var parent = this.input.parentNode;

        if (parent) {
          // Wrap input in a div and append suggestion list
          parent.insertBefore(this.container, this.input);
          this.container.appendChild(this.input);
          this.container.appendChild(this.list);
          this.container.appendChild(this.alerts);
          if (this.options.hide.length > 0 && this.options.unhide == null) this.container.appendChild(this.unhide);
        }

        this.fsm.start();
        this.options.onMounted.call(this);
        this.hideFields();
        return this;
      }
      /**
       * Removes View from DOM
       * - Disable listeners
       * - Removes sugestion list from container
       * - Appends suggestion list to container
       * - Enables listeners
       * - Stops FSM
       */

    }, {
      key: "detach",
      value: function detach() {
        if (this.fsm.status !== n.Running) return this;
        this.input.removeEventListener("input", this.inputListener);
        this.input.removeEventListener("blur", this.blurListener);
        this.input.removeEventListener("focus", this.focusListener);
        this.input.removeEventListener("keydown", this.keydownListener);
        this.list.removeEventListener("mousedown", this.mousedownListener);
        this.container.removeChild(this.list);
        this.container.removeChild(this.alerts);
        var parent = this.container.parentNode;

        if (parent) {
          parent.insertBefore(this.input, this.container);
          parent.removeChild(this.container);
        }

        this.unmountUnhide();
        this.unhideFields();
        this.fsm.stop();
        restoreStyle(this.input, this.inputStyle);
        this.options.onRemove.call(this);
        return this;
      }
      /**
       * Sets message as a list item, no or empty string removes any message
       */

    }, {
      key: "setMessage",
      value: function setMessage(message) {
        this.fsm.send({
          type: "NOTIFY",
          message: message
        });
        return this;
      }
      /**
       * Returns HTML Element which recevies key aria attributes
       *
       * @hidden
       */

    }, {
      key: "ariaAnchor",
      value: function ariaAnchor() {
        if (this.options.aria === "1.0") return this.input;
        return this.container;
      }
      /**
       * Returns current address query
       */

    }, {
      key: "query",
      value: function query() {
        return this.input.value;
      }
      /**
       * Current list of suggestions stored in view
       */

    }, {
      key: "suggestions",
      value: function suggestions() {
        return this.fsm.state.context.suggestions;
      }
      /**
       * Index of currently highlighted suggestion
       */

    }, {
      key: "current",
      value: function current() {
        return this.fsm.state.context.current;
      }
      /**
       * Set address finder suggestions
       */

    }, {
      key: "setSuggestions",
      value: function setSuggestions(suggestions, query) {
        if (query !== this.query()) return this;
        if (suggestions.length === 0) return this.setMessage(this.options.msgNoMatch);
        this.fsm.send({
          type: "SUGGEST",
          suggestions: suggestions
        });
        return this;
      }
      /**
       * Close address finder
       */

    }, {
      key: "close",
      value: function close(reason) {
        this.fsm.send({
          type: "CLOSE",
          reason: reason
        });
        return this;
      }
      /**
       * Open address finder
       */

    }, {
      key: "open",
      value: function open() {
        this.fsm.send("AWAKE");
        return this;
      }
      /**
       * Sets next suggestion as current
       */

    }, {
      key: "next",
      value: function next() {
        this.fsm.send("NEXT");
        return this;
      }
      /**
       * Sets previous suggestion as current
       */

    }, {
      key: "previous",
      value: function previous() {
        this.fsm.send("PREVIOUS");
        return this;
      }
      /**
       * Given a HTMLLiElement, scroll parent until it is in view
       *
       * @hidden
       */

    }, {
      key: "scrollToView",
      value: function scrollToView(li) {
        var liOffset = li.offsetTop;
        var ulScrollTop = this.list.scrollTop;

        if (liOffset < ulScrollTop) {
          this.list.scrollTop = liOffset;
        }

        var ulHeight = this.list.clientHeight;
        var liHeight = li.clientHeight;

        if (liOffset + liHeight > ulScrollTop + ulHeight) {
          this.list.scrollTop = liOffset - ulHeight + liHeight;
        }

        return this;
      }
      /**
       * Moves currently selected li into view
       *
       * @hidden
       */

    }, {
      key: "goto",
      value: function goto(i) {
        var lis = this.list.children;
        var suggestion = lis[i];

        if (i > -1 && lis.length > 0) {
          this.scrollToView(suggestion);
        } else {
          this.scrollToView(lis[0]);
        }

        return this;
      }
      /**
       * Trigger select event on an element or clicked HTMLElement
       */

    }, {
      key: "select",
      value: function select(li) {
        var suggestion;

        if (li) {
          var i;
          var curr = li;

          for (i = 0; curr = curr.previousElementSibling; i += 1) {
          }

          suggestion = this.suggestions()[i];
        } else {
          suggestion = this.suggestions()[this.current()];
        }

        if (suggestion) this.fsm.send({
          type: "SELECT",
          suggestion: suggestion
        });
        return this;
      }
      /**
       * Returns true if address finder is open
       */

    }, {
      key: "opened",
      value: function opened() {
        return !this.closed();
      }
      /**
       * Returs false if address finder is closed
       */

    }, {
      key: "closed",
      value: function closed() {
        return this.fsm.state.matches("closed");
      }
      /**
       * Creates a clickable element that can trigger unhiding of fields
       */

    }, {
      key: "createUnhide",
      value: function createUnhide() {
        var _this = this;

        var e = findOrCreate(this.options.scope, this.options.unhide, function () {
          var e = _this.options.document.createElement("p");

          e.innerText = _this.options.msgUnhide;
          e.setAttribute("role", "button");
          e.setAttribute("tabindex", "0");
          if (_this.options.unhideClass) e.className = _this.options.unhideClass;
          return e;
        });
        e.addEventListener("click", this.unhideEvent);
        return e;
      }
      /**
       * Removes unhide elem from DOM
       */

    }, {
      key: "unmountUnhide",
      value: function unmountUnhide() {
        this.unhide.removeEventListener("click", this.unhideEvent);
        if (this.options.unhide == null && this.options.hide.length) remove(this.unhide);
      }
    }, {
      key: "hiddenFields",
      value: function hiddenFields() {
        var _this2 = this;

        return this.options.hide.map(function (e) {
          if (isString(e)) return toHtmlElem(_this2.options.scope, e);
          return e;
        }).filter(function (e) {
          return e !== null;
        });
      }
      /**
       * Hides fields marked for hiding
       */

    }, {
      key: "hideFields",
      value: function hideFields() {
        this.hiddenFields().forEach(hide);
      }
      /**
       * Unhides fields marked for hiding
       */

    }, {
      key: "unhideFields",
      value: function unhideFields() {
        this.hiddenFields().forEach(show);
        this.options.onUnhide.call(this);
      }
    }]);

    return View;
  }();
  /**
   * Event handler: Fires when focus moves away from input field
   * Triggers:
   * - `onBlur` callback
   * - Closes suggestion list
   *
   * @hidden
   */

  var _onBlur = function _onBlur(self) {
    return function (_) {
      self.options.onBlur.call(self);
      self.close("blur");
    };
  };
  /**
   * Event handler: Fires when input field is focused
   * Triggers:
   * - `onFocus` callback
   * - render of suggestion list
   *
   * @hidden
   */


  var _onFocus = function _onFocus(view) {
    return function (_) {
      view.options.onFocus.call(view);
      view.open();
    };
  };
  /**
   * Event handler: Fires when input is detected on input fiel
   * Triggers:
   * - `onInput` callback
   *
   * @hidden
   */


  var _onInput = function _onInput(view) {
    return function (event) {
      view.fsm.send({
        type: "INPUT",
        event: event
      });
    };
  };
  /**
   * Event handler: Fires when mousedown on `<li>` HTML Entity
   * Triggers:
   * - Selection of address suggestion
   *
   * @hidden
   */


  var _onMousedown = function _onMousedown(view) {
    return function (event) {
      view.options.onMouseDown.call(view, event);
      var ul = view.list;
      var li = event.target;

      if (li !== ul) {
        while (li && !/li/i.test(li.nodeName)) {
          li = li.parentNode;
        }

        if (li && event.button === 0) {
          // Only select on left click
          event.preventDefault();
          view.select(li);
        }
      }
    };
  };
  /**
   * Event handler: Fires on "keyDown" event of search field
   * Triggers:
   * - `select` selection of address if key is "Enter"
   * - `onInput` callback if key is "Backspace"
   * - `close` closing of suggestion list if key is "Esc"
   * - `next` highlight next suggestion if key is "Down"
   * - `previous` highlight next suggestion if key is "Up"
   *
   * @hidden
   */


  var _onKeyDown = function _onKeyDown(view) {
    return function (event) {
      view.options.onKeyDown.call(view, event);
      var key = toKey(event);

      if (view.closed()) {
        view.open();
        return;
      }

      if (view.fsm.state.matches("suggesting")) {
        if (key === "Enter") {
          event.preventDefault();
          view.select();
        }

        if (key === "Backspace") view.fsm.send({
          type: "INPUT",
          event: event
        });

        if (key === "ArrowUp") {
          event.preventDefault();
          view.previous();
        }

        if (key === "ArrowDown") {
          event.preventDefault();
          view.next();
        }
      }

      if (key === "Escape") view.close("esc");
      if (key === "Home") view.fsm.send({
        type: "RESET"
      });
      if (key === "End") view.fsm.send({
        type: "RESET"
      });
    };
  };
  /**
   * Retrieve Element
   * - If string, assumes is valid and returns first match within scope
   * - If null, invokes the create method to return a default
   * - If HTMLElement returns instance
   *
   * @hidden
   */

  var findOrCreate = function findOrCreate(scope, q, create) {
    if (isString(q)) return scope.querySelector(q);
    if (create && q === null) return create();
    return q;
  };

  /**
   * @hidden
   */

  var ApiCache = /*#__PURE__*/function () {
    function ApiCache(client) {
      _classCallCheck(this, ApiCache);

      this.prefix = "!";
      this.client = client;
      this.cache = {};
    }

    _createClass(ApiCache, [{
      key: "key",
      value: function key(query) {
        return "".concat(this.prefix).concat(query.toLowerCase());
      }
    }, {
      key: "retrieve",
      value: function retrieve(query) {
        return this.cache[this.key(query)];
      }
    }, {
      key: "store",
      value: function store(query, data) {
        this.cache[this.key(query)] = data;
        return data;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.cache = {};
      }
      /**
       * Retrieve a list of address suggestions given a query
       *
       * Write and read from cache if previously requested
       */

    }, {
      key: "query",
      value: function query(_query) {
        var _this = this;

        var cachedValue = this.retrieve(_query);
        if (cachedValue) return Promise$1.resolve(cachedValue);
        var p = list(this.client, {
          query: {
            query: _query,
            api_key: this.client.config.api_key
          }
        }).then(function (response) {
          var suggestions = response.body.result.hits;

          _this.store(_query, suggestions);

          return suggestions;
        });
        this.store(_query, p);
        return p;
      }
    }, {
      key: "resolve",
      value: function resolve(suggestion) {
        var umprn = suggestion.umprn,
            udprn = suggestion.udprn;
        if (umprn !== undefined) return lookupUmprn({
          client: this.client,
          umprn: umprn
        });
        return lookupUdprn({
          client: this.client,
          udprn: udprn
        });
      }
    }]);

    return ApiCache;
  }();

  /**
   * Default CSS
   *
   * @hidden
   */

  var d = ".idpc_ul.hidden{display:none}div.idpc_autocomplete{position:relative;margin:0;padding:0;border:0}div.idpc_autocomplete>input{display:block}div.idpc_autocomplete>ul{position:absolute;left:0;z-index:999;min-width:100%;box-sizing:border-box;list-style:none;padding:0;border-radius:.3em;margin:.2em 0 0;background:#fff;border:1px solid rgba(0,0,0,.3);box-shadow:.05em .2em .6em rgba(0,0,0,.2);text-shadow:none;max-height:250px;overflow-y:scroll}div.idpc_autocomplete>ul>li{position:relative;padding:.2em .5em;cursor:pointer}div.idpc_autocomplete>ul>li:hover{background:#b8d3e0;color:#000}div.idpc_autocomplete>ul>li.idpc_error{font-style:italic;background-color:#eee;cursor:default!important}div.idpc_autocomplete>ul>li[aria-selected=true]{background:#3d6d8f;color:#fff;z-index:1000}div.idpc_autocomplete>.idpc-unhide{font-size:90%;text-decoration:underline;cursor:pointer}@supports (transform:scale(0)){div.idpc_autocomplete>ul{transition:.3s cubic-bezier(.4, .2, .5, 1.4);transform-origin:1.43em -0.43em}div.idpc_autocomplete>ul:empty,div.idpc_autocomplete>ul[hidden]{opacity:0;transform:scale(0);display:block;transition-timing-function:ease}}";
  /**
   * Injects CSS style into DOM
   *
   * Idempotent
   *
   * @hidden
   */

  var addStyle = function addStyle(c) {
    var style = c.options.injectStyle;
    if (!style) return;
    var g = idpcState();
    if (!g.afstyle) g.afstyle = {};

    if (isString(style) && !g.afstyle[style]) {
      g.afstyle[style] = true;
      var link = loadStyle(style, c.document);
      c.document.head.appendChild(link);
      return link;
    }

    if (style === true && !g.afstyle[""]) {
      g.afstyle[""] = true;
      return injectStyle(d, c.document);
    }

    return;
  };

  function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * @hidden
   */

  var NOOP = function NOOP() {};
  /**
   * Default options assigned to controller instances
   */

  var defaults = {
    // DOM
    outputScope: null,
    // Client
    apiKey: "",
    checkKey: true,
    // WAI-ARIA compliance settings
    aria: "1.0",
    // Behaviour
    titleizePostTown: true,
    outputFields: {},
    names: {},
    labels: {},
    removeOrganisation: false,
    injectStyle: true,
    inputField: "",
    autocomplete: "none",
    populateCounty: true,
    populateOrganisation: true,
    // Messages
    msgFallback: "Please enter your address manually",
    msgInitial: "Start typing to find address",
    msgNoMatch: "No matches found",
    msgList: "Select your address",
    // View classes
    messageClass: "idpc_error",
    containerClass: "idpc_autocomplete",
    listClass: "idpc_ul",
    // Syles
    inputStyle: {},
    listStyle: {},
    liStyle: {},
    containerStyle: {},
    // Hide / unhide
    unhide: null,
    unhideClass: "idpc-unhide",
    msgUnhide: "Enter address manually",
    hide: [],
    // Callbacks
    onOpen: NOOP,
    onSelect: NOOP,
    onBlur: NOOP,
    onClose: NOOP,
    onFocus: NOOP,
    onInput: NOOP,
    onLoaded: NOOP,
    onSearchError: NOOP,
    onSuggestionError: NOOP,
    onMounted: NOOP,
    onRemove: NOOP,
    onSuggestionsRetrieved: NOOP,
    onAddressSelected: NOOP,
    onAddressRetrieved: NOOP,
    onAddressPopulated: NOOP,
    onFailedCheck: NOOP,
    onMouseDown: NOOP,
    onKeyDown: NOOP,
    onUnhide: NOOP
  };
  /**
   * # Controller
   *
   * The Autocomplete Controller class acts as the public class which you may
   * wield to enable address autocomplete on your HTML address forms
   *
   * When instantiated, the controller will serve as a bridge beteen the
   * address suggestion view presented on the DOM and the Ideal
   * Postcodes Address resolution HTTP APIs
   *
   * More concretely, the instantiation of a controller instance creates:
   * - A user interface instance `View`
   * - An instance of the [Ideal Postcodes Browser Client](https://github.com/ideal-postcodes/core-axios)
   *
   * The role of the controller is to bind to events produced by the user
   * interface and take appropriate action including querying the API,
   * modifying other aspects of the DOM.
   */

  var Controller = /*#__PURE__*/function () {
    function Controller(options) {
      var _this = this;

      _classCallCheck(this, Controller);

      this.options = _objectSpread$2(_objectSpread$2(_objectSpread$2({}, {
        scope: window.document,
        document: window.document
      }), defaults), options); // Default inputField to line_1 if `inputField` not specified

      if (!options.inputField) this.options.inputField = this.options.outputFields.line_1 || ""; // Scope the operations of this controller to a document or DOM subtree

      this.scope = getScope(this.options.scope); // Assign a parent Document for elem creation

      this.document = getDocument(this.scope); // Assign a document or DOM subtree to scope outputs. Defaults to controller scope

      this.outputScope = findOrCreate(this.scope, this.options.outputScope, function () {
        return _this.scope;
      });
      this.client = new Client(_objectSpread$2(_objectSpread$2({}, this.options), {}, {
        api_key: this.options.apiKey
      }));
      this.cache = new ApiCache(this.client);
      this.view = new View(_objectSpread$2(_objectSpread$2({}, this.options), {}, {
        scope: this.scope,
        document: this.document,
        onInput: debounce_1(this._onInput(), 100, {
          leading: true,
          trailing: true,
          maxWait: 100
        }),
        onSelect: this._onSelect()
      }));
      this.init();
    }
    /**
     * Binds to DOM and begin DOM mutations
     *
     * @hidden
     */


    _createClass(Controller, [{
      key: "load",
      value: function load() {
        this.view.attach();
        addStyle(this);
        this.options.onLoaded.call(this);
      }
      /**
       * Attaches Controller to the DOM.
       *
       * If `checkKey` is enabled, a key check will be performed prioer to binding. Use the `onLoaded` and `onFailedCheck` callbacks to define follow up behaviour if the key check succeeds or fails
       */

    }, {
      key: "init",
      value: function init() {
        var _this2 = this;

        return new Promise$1(function (resolve) {
          if (!_this2.options.checkKey) {
            _this2.load();

            resolve();
            return;
          }

          checkKeyUsability({
            client: _this2.client,
            api_key: _this2.options.apiKey
          }).then(function (response) {
            if (!response.available) throw new Error("Key currently not usable");

            _this2.load();

            resolve();
          }).catch(function (error) {
            _this2.options.onFailedCheck.call(_this2, error);

            resolve();
          });
        });
      }
      /**
       * Produces a function to be bound to an instance of `Autocomplete.View`.
       * It executes suggestion search when address input is updated
       *
       * @private
       */

    }, {
      key: "_onInput",
      value: function _onInput() {
        var self = this;
        return function (event) {
          var _this3 = this;

          self.options.onInput.call(this, event);
          var query = this.query();

          if (query.trim().length === 0) {
            this.setMessage(self.options.msgInitial);
            return Promise$1.resolve(this);
          }

          return self.cache.query(query).then(function (suggestions) {
            self.options.onSuggestionsRetrieved.call(self, suggestions);
            return _this3.setSuggestions(suggestions, query);
          }).catch(function (error) {
            if (_this3.query() === query) _this3.setMessage(self.options.msgFallback);
            self.options.onSuggestionError.call(self, error);
            return self.view;
          });
        };
      }
      /**
       * Produces a function to be bound to an instance of `Autocomplete.View`.
       * Populates fields with correct address when suggestion selected
       *
       * @private
       */

    }, {
      key: "_onSelect",
      value: function _onSelect() {
        var self = this;
        return function (suggestion) {
          var _this4 = this;

          self.options.onAddressSelected.call(self, suggestion);
          return self.cache.resolve(suggestion).then(function (address) {
            if (address === null) throw "Unable to retrieve address";
            self.options.onAddressRetrieved.call(self, address);
            self.populateAddress(address);
            return _this4;
          }).catch(function (error) {
            _this4.open();

            _this4.setMessage(self.options.msgFallback);

            self.options.onSearchError.call(self, error);
            return error;
          });
        };
      }
      /**
       * Writes a selected to the input fields specified in the controller config
       *
       * @public
       */

    }, {
      key: "populateAddress",
      value: function populateAddress$1(address) {
        this.view.unhideFields();

        populateAddress({
          address: address,
          config: _objectSpread$2(_objectSpread$2({}, this.options), {}, {
            scope: this.outputScope
          }),
          outputFields: this.options.outputFields,
          names: this.options.names,
          labels: this.options.labels
        });

        this.options.onAddressPopulated.call(this, address);
      }
    }]);

    return Controller;
  }();

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  var isTrue = function isTrue() {
    return true;
  };

  var getAnchors = function getAnchors(config) {
    var scope = getScope(config.scope || null);
    var matches = scope.querySelectorAll(config.anchor || config.inputField || (config.outputFields || {}).line_1);
    return toArray(matches).filter(function (e) {
      return !loaded(e);
    });
  };

  var DEFAULT_INTERVAL = 1000;

  var formScope = function formScope(anchor) {
    return getParent(anchor, "FORM");
  };
  /**
   * Dynamically apply AddressFinder when relevant fields appear
   * - Exits if page test is fails
   * - Check if key usable
   * - Creates a bind method
   *  - Retrives parent scope
   *  - Marks anchor if completed
   * - Creates timer tools
   */


  var watch = function watch(config) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var client = new Client({
      api_key: config.apiKey
    });
    var _options$pageTest = options.pageTest,
        pageTest = _options$pageTest === void 0 ? isTrue : _options$pageTest;
    if (!pageTest()) return Promise$1.resolve(null);
    return checkKeyUsability({
      client: client
    }).then(function (key) {
      if (!key.available) return null;
      var _options$getScope = options.getScope,
          getScope = _options$getScope === void 0 ? formScope : _options$getScope,
          _options$interval = options.interval,
          interval = _options$interval === void 0 ? DEFAULT_INTERVAL : _options$interval,
          anchor = options.anchor,
          _options$onBind = options.onBind,
          onBind = _options$onBind === void 0 ? NOOP : _options$onBind,
          _options$immediate = options.immediate,
          immediate = _options$immediate === void 0 ? true : _options$immediate;

      var bind = function bind() {
        getAnchors(_objectSpread$1({
          anchor: anchor
        }, config)).forEach(function (anchor) {
          var scope = getScope(anchor);
          if (!scope) return;

          var newConfig = _objectSpread$1(_objectSpread$1({
            scope: scope
          }, config), {}, {
            checkKey: false
          });

          var c = setup(newConfig);
          markLoaded(anchor);
          onBind(c);
        });
      };

      var _generateTimer = generateTimer({
        bind: bind,
        pageTest: pageTest,
        interval: interval
      }),
          start = _generateTimer.start,
          stop = _generateTimer.stop;

      if (immediate) start();
      return {
        start: start,
        stop: stop,
        bind: bind
      };
    }).catch(function (e) {
      // Swallow promise errors and raise via optionall onError callback
      if (options.onError) options.onError(e);
      return null;
    });
  };

  /**
   * Configure and launch an instance of the Address Finder
   *
   * This method will create and return a new AddressFinder instance. It will also add a global reference to the controller at `AddressFinder.controllers`
   */

  var setup = function setup(config) {
    var c = new Controller(config);
    return c;
  };

  var hasWindow = function hasWindow() {
    return typeof window !== "undefined";
  };

  var newEvent = function newEvent(_ref) {
    var event = _ref.event,
        _ref$bubbles = _ref.bubbles,
        bubbles = _ref$bubbles === void 0 ? true : _ref$bubbles,
        _ref$cancelable = _ref.cancelable,
        cancelable = _ref$cancelable === void 0 ? true : _ref$cancelable;
    if (typeof window.Event === "function") return new window.Event(event, {
      bubbles: bubbles,
      cancelable: cancelable
    });
    var e = document.createEvent("Event");
    e.initEvent(event, bubbles, cancelable);
    return e;
  };
  var trigger = function trigger(e, event) {
    return e.dispatchEvent(newEvent({
      event: event
    }));
  };

  var isSelect = function isSelect(e) {
    if (e === null) return false;
    return e instanceof HTMLSelectElement;
  };
  var isInput = function isInput(e) {
    if (e === null) return false;
    return e instanceof HTMLInputElement;
  };
  var isTextarea = function isTextarea(e) {
    if (e === null) return false;
    return e instanceof HTMLTextAreaElement;
  };
  var hasValue = function hasValue(select, value) {
    if (value === null) return false;
    return select.querySelector("[value=\"".concat(value, "\"]")) !== null;
  };

  var updateSelect = function updateSelect(_ref) {
    var e = _ref.e,
        value = _ref.value,
        skipTrigger = _ref.skipTrigger;
    if (value === null) return;
    if (!isSelect(e)) return;
    setValue(e, value);
    if (!skipTrigger) trigger(e, "select");
    trigger(e, "change");
  };

  var setValue = function setValue(e, value) {
    var descriptor = Object.getOwnPropertyDescriptor(e.constructor.prototype, "value");
    if (descriptor === undefined) return;
    if (descriptor.set === undefined) return;
    var setter = descriptor.set;
    setter.call(e, value);
  };

  var updateInput = function updateInput(_ref2) {
    var e = _ref2.e,
        value = _ref2.value,
        skipTrigger = _ref2.skipTrigger;
    if (value === null) return;
    if (!isInput(e) && !isTextarea(e)) return;
    setValue(e, value);
    if (!skipTrigger) trigger(e, "input");
    trigger(e, "change");
  };

  var change = function change(options) {
    if (options.value === null) return;
    updateSelect(options);
    updateInput(options);
  };

  var toCiIso = function toCiIso(address) {
    if (/^GY/.test(address.postcode)) return "GG";
    if (/^JE/.test(address.postcode)) return "JE";
    return null;
  };
  var IOM = "Isle of Man";
  var EN = "England";
  var SC = "Scotland";
  var WA = "Wales";
  var NI = "Northern Ireland";
  var CI = "Channel Islands";
  var toIso = function toIso(address) {
    var country = address.country;
    if (country === EN) return "GB";
    if (country === SC) return "GB";
    if (country === WA) return "GB";
    if (country === NI) return "GB";
    if (country === IOM) return "IM";
    if (country === CI) return toCiIso(address);
    return null;
  };

  var g = {};

  if (hasWindow()) {
    if (window.idpcGlobal) {
      g = window.idpcGlobal;
    } else {
      window.idpcGlobal = g;
    }
  }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var config = window.idpcConfig;
  var orderBilling = {
    line_1: "#_billing_address_1",
    line_2: "#_billing_address_2",
    post_town: "#_billing_city",
    county: "#_billing_state",
    postcode: "#_billing_postcode",
    organisation_name: "#_billing_company",
    country: "#_billing_country"
  };
  var orderShipping = {
    line_1: "#_shipping_address_1",
    line_2: "#_shipping_address_2",
    post_town: "#_shipping_city",
    county: "#_shipping_state",
    postcode: "#_shipping_postcode",
    organisation_name: "#_shipping_company",
    country: "#_shipping_country"
  };
  var orderSelectors = [orderBilling, orderShipping];
  orderSelectors.forEach(function (selectors) {
    watch(_objectSpread(_objectSpread({}, config), {}, {
      outputFields: selectors,
      onAddressRetrieved: function onAddressRetrieved(address) {
        var select = document.querySelector(selectors.country);
        var code = toIso(address);
        if (select !== null && code !== null && isSelect(select) && hasValue(select, code)) change({
          e: select,
          value: code
        });
      }
    }), {
      pageTest: function pageTest() {
        return /\/wp-admin/i.test(window.location.href);
      },
      getScope: function getScope() {
        return document.querySelector("div#order_data");
      }
    });
  });

  exports.orderSelectors = orderSelectors;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
